% Consonant Specification, Version 0.0
% Daniel Silverstone (<daniel.silverstone@codethink.co.uk>);
  Jannis Pohlmann (<jannis.pohlmann@codethink.co.uk>)
% July 19th, 2013

# Known Issues

* What if the `consonant.yaml` file changes over time. What if the
  schema being used changes incompatibly or the `consonant.yaml` file
  out of a sudden points to a different version of a schema?
  What if the UUID changes? What if the schema is different between
  different branches of a store?
* The reference stuff in the schema and `properties.yaml` is a bit odd.
  Do we really want to specify the service UUID in the schema? If we
  don't then wouldn't it be very confusing to just see object UUIDs
  from another store in `properties.yaml`? If we do then it's also
  weird in a way. This needs some thought.
* Should references be enforced to be bi-directional? It could be
  really awkward with cross-store references. Would we have to update
  store X if an object in store Y changes its reference to an object
  in store X? What if access control prevents this etc.pp.?

# Introduction

## What is Consonant?

*Consonant* is an object-relational, cross-referenced, verifiable and
service-oriented Git object store and corresponding web API. It is named
after the adjective *consonant* ("characterized by harmony or
agreement"), reflecting its focus on a unified data model and
cross-store referencing and validation.

Consonant is the name given to the overall design. Any implementation
that implements this specification, i.e. uses the same data model and
provides the same API, may call itself a "Consonant implementation".

## Motivation

One of the key aspects of our recent work on Baserock and other projects
has been something we call *traceability*—the ability to tell how data
changed over time, who changed what and why, and how the data in
question looked like at a specific point in time.

Two examples are:

* The requirements and architecture of projects tend to change over
  time. In this context it is often beneficial to understand who
  approved changes when and how the planned work changed over time.
* Kanban is a popular solution for organising work of teams. When
  assessing project productivity and progress, it is essential to have
  ways of telling how a kanban changed over time, e.g. how many cards
  were moved in a day or a week or how the cards linked to a milestone
  have changed from week to week. Among other things this helps
  understanding how realistic milestones are and whether adjustments
  have to be maddiffs.
* References between objects in different data stores:
    - verifiable,
    - versioned.
* Service-oriented design to allow rapid development of interconnected
  web applications on top of Git object stores.

Consonant aims to satisfy this demand by specifying

* a Git/YAML based data model with schemas for type checking and
  validation,
* a RESTful web API for querying and modifying object stores based on
  this data model,
* a mechanism to for referencing objects across different stores.

## Why not use an existing database?

There are a number of reasons for choosing Git over existing relational
or NoSQL databases. Like NoSQL databases, Git is—at its core—a
key-value store for arbitrary data. On top of this, Git offers
versioning, branching and merging, transactions (commits),
de-duplication, offline work and authorship information out of the box,
whereas with other databases you would have to implement a lot of this
yourself.

## Terminology

This specification aims to use consistent terms for the different
aspects of the Consonant design.

* A `Consonant store` is a Git repository that follows the Consonant
  data model.
* A `Consonant service` is a service that provides access to a
  Consonant store via the Consonant web API.
* A `Consonant register` is a YAML file that maps Consonant schema and
  service UUIDs to Consonant services.
* A `Consonant schema` is a YAML file that defines classes for objects
  with typed properties.

# Consonant stores / data model

Representing arbitrary objects in Git requires a unified data model,
allowing different software implementions to access and modify these
objects in a compatible way. This section describes the data model for
Consonant stores.

The central elements of the data model specified in the following
sections are:

* store repositories and service references,
* schemas and schema references,
* classes,
* objects,
* properties,
* attachments.

## Store repository

Every Consonant store is a Git repository. As such it is represented as
a directory that holds the Git key/value store and that can (usually)
be accessed remotely via different protocols. The Git key/value store
consists of data that is addressed by a SHA1 of its content. The
following data elements exist in Git:

* `blob`: a file with specific content,
* `tree`: a directory of specific trees and blobs,
* `commit`: a specific tree, annotated with a list of parent commits
  and other meta data, such as author, committer, commit message and
  so on.

All of the above are stored in Git based on the SHA1 of their contents.
Two files with the same content would result in a single blob that may
be referenced by different trees. Two commits that have the same parents
and introduce the same changes will result in two different commit
elements that reference the same tree (with the modifications made) and
so on.

In addition to the above, heads (flexible, often refered to as branches)
and tags (fixed) can be used to point to specific commits (and therefore
the complete history of a Git tree).

Together this provides the underlying storage mechanism for Consonant
stores.

## Trees and their structure

Each Git tree, whether associated with a commit or not, represents a
particular version or revision of the store's data. The following
elements are present in a tree:

1. A top-level `consonant.yaml` file that contains
    - the store UUID,
    - a reference to the schema defining the object classes used in
      the store,
    - a set of aliased references to external services for
      cross-linking.
2. One top-level directory for each object class for which objects
   have been created (e.g. `/card/`, `/lane/`, `/user/`).
3. One directory in the corresponding object class directory for
   each object that has been created (e.g. `/card/C1234/`,
   `/lane/backlog/`).
4. One `properties.yaml` file in each object directory, storing the
   properties of the object.
5. An optional `attachments/` directory inside each object directory,
   holding arbitrary attachments in pairs of `attachments/<name>` and
   `attachments/.<name>.yaml` files, the latter storing attachment meta
   data.

### Example tree

This is how an example tree for a simple kanban system could look like:

    consonant.yaml
    lane/
        backlog/
            properties.yaml
        doing/
            properties.yaml
        done/
            properties.yaml
    card/
        C1234/
            properties.yaml
            attachments/
                foo.txt
                .foo.txt.yaml
                bar.png
                .bar.png.yaml
        .C5123/
            properties.yaml

## The `consonant.yaml` file

This file defines the unique ID (UUID) and structure of the store as
well as external stores that objects are or may be linking to.

It is a YAML file with three top-level keys:

1. `uuid`: Defines the unique ID (UUID) of the store. The format of
   store UUIDs is specified in the *UUIDs* section.
2. `schema`: A schema reference stating the schema being used in the
   store. This schema defines the object classes available in the store
   and specifies names and types of object properties. For the format
   of schema references see *Schema references*.
3. `services`: A dictionary mapping (preferably short) aliases to
   service references, allowing short and readable cross-references to
   objects in external stores. The exact format of service references
   is specified in *Service references*.

### Schema references

Schema references are strings in one of the following formats,
referencing local or remote schemas:

1. `<schema UUID>`: Reference to a schema by UUID. This reference is
   resolved via the Consonant register (see the *Consonant register*
   section).
2. `http://url.of.a.consonant.service/`: HTTP URL of a Consonant
   service. The Consonant web API supports querying the schema being
   used in a store, allowing services to be linked together in flexible
   ways through references between objects.
3. `http://url.to.a/schema.yaml`: HTTP URL to a remote schema file.
4. `file:///path/to/a/schema.yaml`: Path to a local schema file.

### Service references

Service references are strings in one of the following formats,
referencing external Consonant services.

1. `<service UUID>`: Reference to a service by UUID. This reference is
   resolved via the consonant register (see the *Consonant register*
   section).
2. `http://url.of.a.consonant.service/`: HTTP URL of a Consonant
   service.

### Example `consonant.yaml` file

The following example shows a hypothetical `consonant.yaml` file for
a kanban system that uses its own schema and supports cross-references
to a bug tracking system built on top of Consonant.

    uuid: org.yourproject.kanban.store
    schemas:
        - org.yourproject.kanban.schema.1
    stores:
        bugs: http://bugs.yourproject.org/

## Object classes

Object classes are defined by the schema used in a Consonant store.
Each class for which objects have been created is represented by
a top-level directory that is named after the name of the class, as
specified in the store's schema.

Examples are `/card/`, `/lane/`, `/milestone/` for card, lane and
milestone objects in a kanban system or `/project/`, `/component/` and
`/issue/` for project, component and issue objects in a bug tracker.

## Objects

Each object created in a Consonant store is represented by an object
directory inside the corresponding class directory. Object directories
are named after object UUIDs.

Examples are `/card/C423/` (for a kanban card with the number 423),
`/lane/backlog/` (for a backlog lane in a kanban system) and
`/milestone/15/` (for the 15th milestone defined in a project).

The format of object UUIDs may vary and is specified in the schema used
by the store (see the *Schemas* section for more details).

Objects would be useless if all they consisted of was a class and a
name. Like in many programming languages, Consonant objects have
so-called properties. They come in three variants:

1. a special property to hide objects,
2. properties specified by schemas and set in `properties.yaml` files,
3. arbitrary data properties called *attachments*.

### Hidden objects

A special feature of Consonant stores is that objects can be hidden by
prepending a dot to their directory name (e.g. `/card/.C503/`). This
is similar to hiding files on file systems.

Hidden objects are not parsed and loaded into memory unless explicitly
requested. Depending on the amount of data, this can result in
significant performance boosts. However, hidden objects still remain
present in the store so that their existence and history can be
determined without having to locate them in the revision history of
the entire store.

Hiding files can have different semantic meanings. One example would
be "archiving" cards in a kanban system in order to mark them as
obsolete while at the same time preserving a view of all archived
cards for project managers and statistics.

### The `properties.yaml` file

The `properties.yaml` files contain the mandatory and optional
properties for individual objects. There is one file for each object,
located in the object directory (e.g. `/card/C593/properties.yaml`).

Like the file extension suggests, `properties.yaml` files are YAML
files. They each hold a flat dictionary that maps property names to
property values. The data types supported for properties are explained
in the *Schemas* section.

#### Example `properties.yaml` file

The following example shows a hypothetical `properties.yaml` file for
a lane in a kanban system, including the properties `name` (string),
`description` (text, multi-line), `color` (string), `cards` (list of
internal references to objects of the class `card`).

    name: Doing
    description: |
        Tasks that are currently being worked on. Cards are
        being moved here from the "Backlog" and are moved to
        "Done" after being processed.
    color: #ffa500
    cards:
        - C513
        - C506
        - C654

### The `attachments` directory

In addition to regular properties that are defined in schemas, each
object may store arbitrary properties called *attachments*. These are
stored as pairs of files in an `attachments/` subdirectory inside the
object directory (e.g. `/card/C854/attachments/`).

Attachments consist of a name (e.g. `comments` or `mockup.png`),
the actual data and arbitrary YAML meta data. All this is stored in
the `attachments/` directory as follows:

1. `attachments/NAME`: holds the attachment data,
2. `attachments/.NAME.yaml`: holds the attachment meta data,

where `NAME` is the name of the attachment.

#### Example `attachments` directory

The following example shows a hypothetical listing of an attachments
directory for issue `6031` in a bug tracker:

    /issue/6031/attachments/patch-v1.patch
    /issue/6031/attachments/.patch-v1.patch.yaml
    /issue/6031/attachments/patch-v2.patch
    /issue/6031/attachments/.patch-v2.patch.yaml

The YAML meta data in `.patch-v1.patch.yaml` could look like this:

    description: |
        This patch is a first attempt at fixing issue 6031.
        It is caused by accidently overwriting the value of
        `foo` in the for loop in `bla.c`.
    patch: true
    content-type: text/plain

## UUIDs

Universally unique identifiers (UUIDs) are being used to refer to other
objects, schemas or stores/services. The term "universal" is a little
confusing here: while creators of schemas and stores are encouraged to
use globally unique identifiers (see below), there is no way to
guarantee this. Identifiers of objects only have to be unique within
a store.

### Object UUIDs

Identifiers of objects are required to be unique within a store. Their
format is flexible and is defined via regular expressions in schemas.
See the *Schemas* section for details.

Despite this, there are a few characters that are excluded from object
UUIDs:

* whitespace characters such as spaces, tabs or newlines,
* non-ASCII characters,
* any of the following characters: `,:@%()[]{}\`.

### Schema UUIDs

Identifiers of schemas are required to be of the form

    some.domain.schemaname.1

meaning that they follow a reverse domain notation similar to that used
for Java packages/classes and D-Bus service names. A special requirement
is the mandatory final segment of the UUID, which specifies the schema
version.

### Store/service UUIDs

Identifiers of stores/services are required to be of the form

    some.domain.storename

meaning that they follow a reverse domain notation similar to that used
for Java packages/classes and D-Bus service names.

## The Consonant register

The *Consonant register* is a special configuration file that allows
to register Consonant services and schemas system-wide or per-user. It is
is used to resolve UUID-based schema and store imports in
`consonant.yaml`.

The Consonant register is located according to the
[XDG Base Directory Specification](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html),
that is, the system register is stored in

    $XDG_CONFIG_DIRS/consonant/register.yaml

and the user register is stored in

    $XDG_CONFIG_HOME/consonant/register.yaml.

Register files are YAML files that contain the following two keys:

1. `schemas`: a dictionary mapping schema UUIDs to fully qualified
   schema locations (HTTP schema query URLs, local store
   repositories or or local schema files).
2. `services`: a dictionary mapping store/service UUIDs to fully
   qualified HTTP service URLs.

Whenever the same mapping appears in both, the system-wide register
and the per-user register, the mapping in the user register takes
precedence and overrides the system-wide one.

### Example register

The following examples shows a hypothetical system and user register
defining mappings for schemas and stores for a kanban and bug tracking
system. The user mapping for the bug tracker overrides the system-wide
setting for a local installation of the bug tracking service (and
store).

System register:

    schemas:
        org.project.kanban.schema.1: http://kanban.project.org/
        org.project.bugs.schema.1:   http://bugs.project.org/
    stores:
        org.project.kanban.store:    http://kanban.project.org/
        org.project.bugs.store:      http://bugs.project.org/

Registry of user `jeff`:

    stores:
        org.project.bugs.store:      http://localhost:8080/

## Schemas

Schemas are YAML files that define the object classes available for
use in a Consonant store.

### Schema files

Schemas are defined via YAML files, of which there is one per schema.
Schema files contain the following top-level keys:

* `uuid`: the UUID of the schema (see the *Schemas* section for more
  information).
* `classes`: a mapping of class names to class definitions, each
  including an object UUID format and a set of property definitions.

### Class definitions

Classes are defined via the `classes` mapping in schema files. Their
definition includes:

* a class name,
* an object UUID format, and
* a set of object property definitions.

The class name is given by the key they are stored under in `classes`.
The object UUID format and property definitions are defined as follows:

* an `uuid-format` key in the class definition,
* a `properties` key in the class definition, which is itself a
  dictionary that maps object property names to their definitions.

The following example shows (partial) hypothetical schema for a kanban
system based on Consonant, defining two classes for kanban lanes and
cards, respectively:

    uuid: org.yourproject.kanban.schema1
    lane:
        uuid-format: ^[a-z]+$
        properties:
            ...
    cards:
        uuid-format: ^C[1-9][0-9]*$
        properties:
            ...

### Object UUID formats

TODO

### Object properties

Object properties are defined as a dictionary under the `properties`
key of class definitions. Each property definition includes

* a name,
* a data type,
* data type specific hints (e.g. for validation rules), and
* an `optional` hint.

Properties may also be marked optional via the `optional` hint.

### Property names

Property names are alphanumeric strings that may contain dashes as
delimiters. Property names must start with a letter and may not end with
a dash.

Examples of valid property names are: `title`, `email-address`,
`property1`.

### Property data types

Object properties are strictly typed, meaning that each property is
associated with a data type and optional validation rules. This
information is used by Consonant implementations to validate entire
data stores.

The following table lists all data types supported by Consonant schemas.

+-------------+-------------------------------------------------------------+
| Name        | Description                                                 |
+=============+=============================================================+
| boolean     | Data type with only two possible values: `true` or `false`. |
+-------------+-------------------------------------------------------------+
| int         | Data type for 64 bit signed integers.                       |
+-------------+-------------------------------------------------------------+
| float       | Data type for double-precision floating-point numbers.      |
+-------------+-------------------------------------------------------------+
| string      | Data type for one-line strings.                             |
+-------------+-------------------------------------------------------------+
| text        | Data type for multi-line strings.                           |
+-------------+-------------------------------------------------------------+
| reference   | Data type for references to other objects, either in the    |
|             | same or a different Consonant store.                        |
+-------------+-------------------------------------------------------------+
| list        | Data type for lists of values of another basic data type.   |
|             | Lists may be nested.                                        |
+-------------+-------------------------------------------------------------+

### Properties of type `boolean`

#### Definition

Boolean properties are specified in schema files as follows:

    <name>:
        type: boolean

#### Usage

Assume we were to write a Consonant schema for a kanban system. A kanban
card might have an optional boolean property `doable` to mark it as a
small task that can be done in less then a day. In the schema, this would
look as follows:

    uuid: org.yourproject.kanban.schema.1
    classes:
        card:
            uuid-format: ^C[1-9][0-9]*$
            doable:
                type: boolean
                optional: true

A card `/card/C105` might have this property set, in which case its
`properties.yaml` file in the corresponding Consonant store would like
like this:

    doable: true

#### Values

Allowed values of boolean properties are: `true`, `false`.

### Properties of type `int`

#### Definition

Integer properties are specified in schema files as follows:

    <name>:
        type: int

#### Usage

Assume we were to write a Consonant schema for a kanban system. A kanban
card might have a mandatory `estimated-days` property to estimate the
amount of days needed to finish the task. The resulting schema would
look as follows:

    uuid: org.myproject.kanban.schema.1
    classes:
        card:
            uuid-format: ^C[1-9][0-9]*$
            doable:
                type: boolean
                optional: true
            estimated-days:
                type: int

Every card (e.g. `/card/C105`) would have to have this property set,
resulting in `properties.yaml` files like the following:

    estimated-days: 3
    doable: false

The above includes the `doable` property from the boolean property
example to demonstrate how a `properties.yaml` file with multiple
properties would look like.

#### Values

All `int` properties are 64 bit integers with allowed values ranging
from -9,223,372,036,854,775,808 to +9,223,372,036,854,775,807.

### Properties of type `float`

#### Definition

Floating point properties are specified in schema files as follows:

    <name>:
        type: float

#### Usage

Assume we were to write a Consonant schema for a personal finance
system with multiple bank accounts. A bank account might have a
floating point property for the current amount of money in the
account. The resulting schema would
look as follows:

    uuid: uk.me.yourname.banking.schema.1
    classes:
        account:
            uuid-format: ^[a-zA-Z-]+$
            properties:
                current-amount:
                    type: float

Every account (e.g. `/account/savings`) would have to have this
property set, resulting in `properties.yaml` files like the
following:

    current-amount: 159.27

#### Values

All floating point properties support double precision values.

### Properties of type `string`

#### Definition

String properties are specified in schema files as follows:

    <name>:
        type: string

They may optionally include a regular expression as a validation
requirement for implementations:

    <name>:
        type: string
        regex: ^[a-zA-Z0-9]$

#### Usage

Assume we were to write a Consonant schema for a kanban system where
each card has a title associated with it. The resulting schema would
look as follows:

    uuid: org.yourproject.kanban.schema.1
    classes:
        card:
            uuid-format: ^C[1-9][0-9]*$
            properties:
                title:
                    type: string

Every card (e.g. `/cards/C105`) would have to have this property
set, resulting in `properties.yaml` files like the following:

    title: Finish the schemas section of the Consonant spec

#### Values

Allowed values are any strings that contain no newline characters.
If a `regex` validation rule is defined, the strings must in addition
satisfy the given regular expression.

### Properties of type `text`

Text properties are the same as strings except that they do not
support `regex` validation rules and may, unlike strings, contain
newlines. Any newline characters provided as input to a string
property are preserved. For example, the value

    This is a two-line description for
    a kanban card.

would be preserved in a `properties.yaml` file as:

    description: |
        This is a two-line description for
        a kanban card.

### Properties of type `reference`

#### Definition

Reference properties are used to describe references from one object
to another. References may be internal (within the same store) or
external (to objects in a different store). References may also include
a particular target tree or commit (again, in the same or a different
store).

Reference properties are defined as follows:

    <name>:
        type: reference
        class: <target class name>

They may optionally include a store/service UUID to indicate referencing
of objects in a different store than the one the schema is being used
in:

    <name>:
        type: reference
        class: <target class name>
        service-uuid: <service UUID>

#### Usage

Assume we had the following service registered with Consonant via the
Consonant register:

    services:
        org.yourproject.issues: http://issues.yourproject.org/

Assume further that we were to define a schema for a kanban system
based on Consonant where cards refer to the lanes they are in and
optionally refer to an issue in our issue tracker. The kanban schema
for this could include the following:

    uuid: org.yourproject.kanban.schema.1
    classes:
        lane:
            uuid-format: ^[a-z]+$
            properties:
                ...
        card:
            uuid-format: ^C[1-9][0-9]*$
            properties:
                lane:
                    type: reference
                    class: lane
                issue:
                    type: reference
                    class: issue
                    service-uuid: org.yourproject.issues
                    optional: true

Every card in the kanban store would have to have a reference to one of
the lanes and, optionally, a reference to an issue in the issue tracker.
An example could be:

    lane: backlog
    issue: bug209

where `bug209` is the UUID of an issue in the issue tracker.

TODO: Rethink/rework the above and continue.

#### Values

### Properties of type `list`

#### Definition

List properties are defined in schemas as follows:

    <name>:
        type: list
        elements:
            <type definition for elements>

One example would be a list of lists of strings:

    <name>:
        type: list
        elements:
            type: list
            elements:
                type: string

Lists are required to always contain at least one element. The
`optional` flag can be used to define list properties that may be empty
(by not being set at at all).

#### Usage

Assume we were to define a Consonant schema for a kanban system with
lanes and cards. Assume further that lanes maintain a list of references
to the cards in them. The resulting schema might look like this:

    uuid: org.yourproject.kanban.schema.1
    classes:
        lane:
            uuid-format: ^[a-z]+$
            properties:
                title: string
                cards:
                    type: list
                    elements:
                        type: reference
                        class: card
                optional: true
        card:
            uuid-format: ^C[1-9][0-9]*$
            ...

A "backlog" lane with three cards could then have the following content
in `properties.yaml`:

    title: Backlog
    cards:
        - C198
        - C503
        - C93

#### Values

If present in `properties.yaml` files, lists must be non-empty. Empty
list properties are realised through the `optional` flag. The allowed
values of list elements depend entirely on the element data type
specified.

### Example schemas

#### Example kanban schema

#### Example issues schema

# Consonant services / data interface

<!--
## Schemas

Schemas are files that describe the object classes available for use in
an object store. Definitions of classes include a class name and a list
of properties. Each property definition includes a name, basic data type
and data type specific information (e.g. for validating strings).
Properties may also be marked optional via the `optional=<true|false>`
field.

The following basic data types are supported:

+------------+--------------------------------------+-----------------------------------------------------+
| Name       | Description                          | Extra fields                                        |
+============+======================================+=====================================================+
| string     | A single line of text.               |                                                     |
+------------+--------------------------------------+-----------------------------------------------------+
| regex      | A regular expression for validating  |                                                     |
|            | the value of a string property       |                                                     |
+------------+--------------------------------------+-----------------------------------------------------+
| text       | Multiple lines of text.              |                                                     |
+------------+--------------------------------------+-----------------------------------------------------+
| list       | List of values of another data type. | * type - basic data type of list elements           |
+------------+--------------------------------------+-----------------------------------------------------+
| ref        | Reference to another object.         | * *class* - name of the class of referenced objects |
|            |                                      | * *store* - alias, UUID, path or URL to an HTTP     |
|            |                                      |   object store service that the holds the           |
|            |                                      |   referenced objects                                |
+------------+--------------------------------------+-----------------------------------------------------+

Table: Data types supported by the generic Git object store.

An example schema could look as follows

    org.myproject.schemas.kanban.yaml:
    uuid: org.myproject.schemas.kanban
        lane:
            title:
                kind: string
                regex: ^.*$
            cards:
                kind: list
                type: ref
                class: card
            colour:
                kind: string
                regex: ^#([0-9abcdefABCDEF]{6})$
        card:
            issue:
                kind: ref
                class: issue
                store: issues
                optional: true

An example schema file called `org.myproject.schemas.kanban` could look
as follows

    uuid: org.myproject.schemas.kanban
        lane:
            title:
                kind: string
                regex: ^.*$
            cards:
                kind: list
                type: ref
                class: card
            colour:
                kind: string
                regex: ^#([0-9abcdefABCDEF]{6})$
        card:
            issue:
                kind: ref
                class: issue
                store: issues
                optional: true

## Object References

TODO

Three types:

1. Internal: `<UUID>`
2. Simple external: `<prefix>:<UUID>` (e.g. `kanban:S1234`)
3. Advanced external: `<prefix>@<ref>:<UUID>` (e.g. `kanban@master:S1234`)

Web API convention for resolving links:

* `GET /gitstore/api/1.0/resolve/<UUID>/<ref>`
* e.g. `GET /gitstore/api/1.0/resolve/S1234/master`
* HTTP response codes:
    - 404 - not found
    - 302 - found, redirecting to service-specific link (e.g.
      <http://kanban.foo.org/card/S1234>)
    - 351 (?) - multiple choices, i.e., ambiguous ref

## Example Object Store Tree

TODO

# RESTful Web API for Object Stores

TODO

# Linking Object Stores Together

TODO

Config file to register local or remote stores (`~/.gitstore.conf`):

    <UUID>: <local path or http:// URL>
    <UUID>: <local path or http:// URL>

# Python Base Library

TODO

Have a Python base library that

* implements the data model based on pygit2 in a generic way
* can spin up a RESTful web service to query and modify a given data
  store
* allows hooks for UUID generation, authentication, authorisation etc.
  to develop an LDAP authentication layer and specific web applications
  for different services (MUSTARD, Kanban) on top:

        /gitstore/api/1.0/resolve/...
        /gitstore/api/1.0/create/...
        /gitstore/api/1.0/delete/...
        /gitstore/api/1.0/hide/...
        /gitstore/api/1.0/modify/...
* uses <http://sendapatch.se/projects/pylibmc/> for caching parsed YAML
  blobs (which is the thing that is likely to slow things down most)
-->
