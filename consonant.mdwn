% Consonant Specification, Version 0.0
% Daniel Silverstone (<daniel.silverstone@codethink.co.uk>);
  Jannis Pohlmann (<jannis.pohlmann@codethink.co.uk>)
% July 23th, 2013

# Known Issues

* What if the `consonant.yaml` file changes over time. What if the
  schema being used changes incompatibly or the `consonant.yaml` file
  out of a sudden points to a different version of a schema?
  What if the UUID changes? What if the schema is different between
  different branches of a store?

# Introduction

## What is Consonant?

*Consonant* is an object-relational, cross-referenced, verifiable and
service-oriented Git object store and corresponding web API. It is named
after the adjective *consonant* ("characterized by harmony or
agreement"), reflecting its focus on a unified data model and
cross-store referencing and validation.

Consonant is the name given to the overall design. Any implementation
that implements this specification, i.e. uses the same data model and
provides the same API, may call itself a "Consonant implementation".

## Motivation

One of the key aspects of our recent work on Baserock and other projects
has been something we call *traceability*—the ability to tell how data
changed over time, who changed what and why, and how the data in
question looked like at a specific point in time.

Two examples are:

* The requirements and architecture of projects tend to change over
  time. In this context it is often beneficial to understand who
  approved changes when and how the planned work changed over time.
* Kanban is a popular solution for organising work of teams. When
  assessing project productivity and progress, it is essential to have
  ways of telling how a kanban changed over time, e.g. how many cards
  were moved in a day or a week or how the cards linked to a milestone
  have changed from week to week. Among other things this helps
  understanding how realistic milestones are and whether adjustments
  have to be maddiffs.
* References between objects in different data stores:
    - verifiable,
    - versioned.
* Service-oriented design to allow rapid development of interconnected
  web applications on top of Git object stores.

Consonant aims to satisfy this demand by specifying

* a Git/YAML based data model with schemas for type checking and
  validation,
* a RESTful web API for querying and modifying object stores based on
  this data model,
* a mechanism to for referencing objects across different stores.

## Why not use an existing database?

There are a number of reasons for choosing Git over existing relational
or NoSQL databases. Like NoSQL databases, Git is—at its core—a
key-value store for arbitrary data. On top of this, Git offers
versioning, branching and merging, transactions (commits),
de-duplication, offline work and authorship information out of the box,
whereas with other databases you would have to implement a lot of this
yourself.

## Terminology

This specification aims to use consistent terms for the different
aspects of the Consonant design.

* A `Consonant store` is a Git repository that follows the Consonant
  data model.
* A `Consonant service` is a service that provides access to a
  Consonant store via the Consonant web API.
* A `Consonant register` is a YAML file that maps Consonant schema and
  service UUIDs to Consonant services.
* A `Consonant schema` is a YAML file that defines classes for objects
  with typed properties.

# Consonant stores / data model

Representing arbitrary objects in Git requires a unified data model,
allowing different software implementions to access and modify these
objects in a compatible way. This section describes the data model for
Consonant stores.

The central elements of the data model specified in the following
sections are:

* store repositories and service references,
* schemas and schema references,
* classes,
* objects,
* properties,
* attachments.

## Store repository

Every Consonant store is a Git repository. As such it is represented as
a directory that holds the Git key/value store and that can (usually)
be accessed remotely via different protocols. The Git key/value store
consists of data that is addressed by a SHA1 of its content. The
following data elements exist in Git:

* `blob`: a file with specific content,
* `tree`: a directory of specific trees and blobs,
* `commit`: a specific tree, annotated with a list of parent commits
  and other meta data, such as author, committer, commit message and
  so on.

All of the above are stored in Git based on the SHA1 of their contents.
Two files with the same content would result in a single blob that may
be referenced by different trees. Two commits that have the same parents
and introduce the same changes will result in two different commit
elements that reference the same tree (with the modifications made) and
so on.

In addition to the above, heads (flexible, often refered to as branches)
and tags (fixed) can be used to point to specific commits (and therefore
the complete history of a Git tree).

Together this provides the underlying storage mechanism for Consonant
stores.

## Trees and their structure

Each Git tree, whether associated with a commit or not, represents a
particular version or revision of the store's data. The following
elements are present in a tree:

1. A top-level `consonant.yaml` file that contains
    - the store UUID,
    - a reference to the schema defining the object classes used in
      the store,
    - a set of aliased references to external services for
      cross-linking.
2. One top-level directory for each object class for which objects
   have been created (e.g. `/card/`, `/lane/`, `/user/`).
3. One directory in the corresponding object class directory for
   each object that has been created (e.g. `/card/C1234/`,
   `/lane/backlog/`).
4. One `properties.yaml` file in each object directory, storing the
   properties of the object.
5. An optional `attachments/` directory inside each object directory,
   holding arbitrary attachments in pairs of `attachments/<name>` and
   `attachments/.<name>.yaml` files, the latter storing attachment meta
   data.

### Example tree

This is how an example tree for a simple kanban system could look like:

    consonant.yaml
    lane/
        backlog/
            properties.yaml
        doing/
            properties.yaml
        done/
            properties.yaml
    card/
        C1234/
            properties.yaml
            attachments/
                foo.txt
                .foo.txt.yaml
                bar.png
                .bar.png.yaml
        .C5123/
            properties.yaml

## The `consonant.yaml` file

This file defines the unique ID (UUID) and structure of the store as
well as external stores that objects are or may be linking to.

It is a YAML file with three top-level keys:

1. `uuid`: Defines the unique ID (UUID) of the store. The format of
   store UUIDs is specified in the *UUIDs* section.
2. `schema`: A schema reference stating the schema being used in the
   store. This schema defines the object classes available in the store
   and specifies names and types of object properties. For the format
   of schema references see *Schema references*.
3. `services`: A dictionary mapping (preferably short) aliases to
   service references, allowing short and readable cross-references to
   objects in external stores. The exact format of service references
   is specified in *Service references*.

### Schema references

Schema references are strings in one of the following formats,
referencing local or remote schemas:

1. `<schema UUID>`: Reference to a schema by UUID. This reference is
   resolved via the Consonant register (see the *Consonant register*
   section).
2. `<scheme>://<url to a schema>`: URL to a schema file. Implementations
   are required to support `http`, `https` and `file` URLs.

### Service references

Service references are strings in one of the following formats,
referencing external Consonant services.

1. `<service UUID>`: Reference to a service by UUID. This reference is
   resolved via the consonant register (see the *Consonant register*
   section).
2. `<scheme>://<url to a service>`: URL to a Consonant service.
   Implementations are required to support `http`, `https` and `file`
   URLs. `file` URLs specify local Consonant stores rather than service
   end points, which implies that implementations resolving `file` URLs
   need to be able to activate services for these stores on demand.

### Example `consonant.yaml` file

The following example shows a hypothetical `consonant.yaml` file for
a kanban system that uses its own schema and supports cross-references
to a bug tracking system built on top of Consonant.

    uuid: org.yourproject.kanban.store
    schema: org.yourproject.kanban.schema.1
    stores:
        issues: http://issues.yourproject.org/

## Object classes

Object classes are defined by the schema used in a Consonant store.
Each class for which objects have been created is represented by
a top-level directory that is named after the name of the class, as
specified in the store's schema.

Examples are `/card/`, `/lane/`, `/milestone/` for card, lane and
milestone objects in a kanban system or `/project/`, `/component/` and
`/issue/` for project, component and issue objects in a bug tracker.

## Objects

Each object created in a Consonant store is represented by an object
directory inside the corresponding class directory. Object directories
are named after object UUIDs.

Examples are `/card/C423/` (for a kanban card with the number 423),
`/lane/backlog/` (for a backlog lane in a kanban system) and
`/milestone/15/` (for the 15th milestone defined in a project).

The format of object UUIDs may vary and is specified in the schema used
by the store (see the *Schemas* section for more details).

Objects would be useless if all they consisted of was a class and a
name. Like in many programming languages, Consonant objects have
so-called properties. They come in three variants:

1. a special property to hide objects,
2. properties specified by schemas and set in `properties.yaml` files,
3. arbitrary data properties called *attachments*.

### Hidden objects

A special feature of Consonant stores is that objects can be hidden by
prepending a dot to their directory name (e.g. `/card/.C503/`). This
is similar to hiding files on file systems.

Hidden objects are not parsed and loaded into memory unless explicitly
requested. Depending on the amount of data, this can result in
significant performance boosts. However, hidden objects still remain
present in the store so that their existence and history can be
determined without having to locate them in the revision history of
the entire store.

Hiding files can have different semantic meanings. One example would
be "archiving" cards in a kanban system in order to mark them as
obsolete while at the same time preserving a view of all archived
cards for project managers and statistics.

### The `properties.yaml` file

The `properties.yaml` files contain the mandatory and optional
properties for individual objects. There is one file for each object,
located in the object directory (e.g. `/card/C593/properties.yaml`).

Like the file extension suggests, `properties.yaml` files are YAML
files. They each hold a flat dictionary that maps property names to
property values. The data types supported for properties are explained
in the *Schemas* section.

#### Example `properties.yaml` file

The following example shows a hypothetical `properties.yaml` file for
a lane in a kanban system, including the properties `name` (text),
`description`, `color` (text), `cards` (list of internal references
to objects of the class `card`).

    name: Doing
    description: |
        Tasks that are currently being worked on. Cards are
        being moved here from the "Backlog" and are moved to
        "Done" after being processed.
    color: #ffa500
    cards:
        - C513
        - C506
        - C654

### The `attachments` directory

In addition to regular properties that are defined in schemas, each
object may store arbitrary properties called *attachments*. These are
stored as pairs of files in an `attachments/` subdirectory inside the
object directory (e.g. `/card/C854/attachments/`).

Attachments consist of a name (e.g. `comments` or `mockup.png`),
the actual data and arbitrary YAML meta data. All this is stored in
the `attachments/` directory as follows:

1. `attachments/NAME`: holds the attachment data,
2. `attachments/.NAME.yaml`: holds the attachment meta data,

where `NAME` is the name of the attachment.

#### Example `attachments` directory

The following example shows a hypothetical listing of an attachments
directory for issue `6031` in a bug tracker:

    /issue/6031/attachments/patch-v1.patch
    /issue/6031/attachments/.patch-v1.patch.yaml
    /issue/6031/attachments/patch-v2.patch
    /issue/6031/attachments/.patch-v2.patch.yaml

The YAML meta data in `.patch-v1.patch.yaml` could look like this:

    description: |
        This patch is a first attempt at fixing issue 6031.
        It is caused by accidently overwriting the value of
        `foo` in the for loop in `bla.c`.
    patch: true
    content-type: text/plain

## UUIDs

Universally unique identifiers (UUIDs) are being used to refer to other
objects, schemas or stores/services. The term "universal" is a little
confusing here: while creators of schemas and stores are encouraged to
use globally unique identifiers (see below), there is no way to
guarantee this. Identifiers of objects only have to be unique within
a store.

### Object UUIDs

Identifiers of objects are required to be unique within a store. Their
generation is left to Consonant implementations. However, they must be
a mix of alphanumeric characters and dashes and must not begin or end
with a dash:

    ^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])$

### Schema UUIDs

Identifiers of schemas are required to be of the form

    some.domain.schemaname.1

meaning that they follow a reverse domain notation similar to that used
for Java packages/classes and D-Bus service names. A special requirement
is the mandatory final segment of the UUID, which specifies the schema
version.

### Store/service UUIDs

Identifiers of stores/services are required to be of the form

    some.domain.storename

meaning that they follow a reverse domain notation similar to that used
for Java packages/classes and D-Bus service names.

## The Consonant register

The *Consonant register* is a special configuration file that allows
to register Consonant services and schemas system-wide or per-user. It is
is used to resolve UUID-based schema and store imports in
`consonant.yaml`.

The Consonant register is located according to the
[XDG Base Directory Specification](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html),
that is, the system register is stored in

    $XDG_CONFIG_DIRS/consonant/register.yaml

and the user register is stored in

    $XDG_CONFIG_HOME/consonant/register.yaml.

Register files are YAML files that contain the following two keys:

1. `schemas`: a dictionary mapping schema UUIDs and URLs to local file
   paths.
2. `services`: a dictionary mapping service UUIDs to service URLs.

Whenever the same mapping appears in both the system-wide register
and the per-user register the mapping in the user register takes
precedence and overrides the system-wide one.

### Example register

The following examples shows a hypothetical system and user register
defining mappings for schemas and stores for a kanban and bug tracking
system. The user mapping for the bug tracker overrides the system-wide
setting for a local installation of the bug tracking service (and
store).

System register:

    schemas:
        org.project.kanban.schema.1: /usr/share/consonant/schemas/org.project.kanban.schema.1
        org.project.issues.schema.1: /usr/share/consonant/schemas/org.project.issues.schema.1

Registry of user `jeff`:

    stores:
        org.project.issues.store: http://localhost:8080/

## Schemas

Schemas are YAML files that define the object classes available for
use in a Consonant store.

### Schema files

Schemas are defined via YAML files, of which there is one per schema.
Schema files contain the following top-level keys:

* `uuid`: the UUID of the schema (see the *Schemas* section for more
  information).
* `classes`: a mapping of class names to class definitions, each
  consisting of a set of property definitions.

### Class definitions

Classes are defined via a class name that is mapped to a set of object
property definitions inside the `classes` mapping in schema files.

The class name is the key the class is stored under in `classes`.

The property definitions are defined via a `properties` key under the
class name entry that is mapped to a dictionary, which in turn maps
object property names to their definitions.

The following example shows (partial) hypothetical schema for a kanban
system based on Consonant, defining two classes for kanban lanes and
cards, respectively:

    uuid: org.yourproject.kanban.schema1
    classes:
        lane:
            properties:
                ...
        cards:
            properties:
                ...

### Object properties

Object properties are defined as a dictionary under the `properties`
key of class definitions. Each property definition includes

* a name,
* a data type,
* data type specific hints (e.g. validation rules), and
* an `optional` hint.

### Property names

Property names are alphanumeric strings that may contain dashes as
delimiters. Property names must start with a letter and may not end with
a dash. They must have a minimum length of 2 characters. Property
names can be validated using the following regular expression:

    ^[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9]$

Examples of valid property names are: `id`, `title`, `email-address`,
`property1`.

### Property data types

Object properties are strictly typed, meaning that each property is
associated with a data type and optional validation rules. This
information is used by Consonant implementations to validate entire
data stores.

The following table lists all data types supported by Consonant schemas.

+-------------+-------------------------------------------------------------+
| Name        | Description                                                 |
+=============+=============================================================+
| boolean     | Data type with only two possible values: `true` or `false`. |
+-------------+-------------------------------------------------------------+
| int         | Data type for 64 bit signed integers.                       |
+-------------+-------------------------------------------------------------+
| float       | Data type for double-precision floating-point numbers.      |
+-------------+-------------------------------------------------------------+
| text        | Data type for arbitrary text. Whitespace is preserved.      |
+-------------+-------------------------------------------------------------+
| reference   | Data type for references to other objects, either in the    |
|             | same or a different Consonant store.                        |
+-------------+-------------------------------------------------------------+
| list        | Data type for lists of values of another basic data type.   |
|             | Lists may be nested.                                        |
+-------------+-------------------------------------------------------------+

### Properties of type `boolean`

#### Definition

Boolean properties are specified in schema files as follows:

    <name>:
        type: boolean

#### Usage

Assume we were to write a Consonant schema for a kanban system. Kanban
cards might have a boolean property `doable` to mark them as small
tasks that can be completed in less then a day. In the schema, this
would look as follows:

    uuid: org.yourproject.kanban.schema.1
    classes:
        card:
            properties:
                doable:
                    type: boolean

A card `/card/C105` might have this property set, in which case its
`properties.yaml` file in the corresponding Consonant store would like
like this:

    doable: true

#### Values

Allowed values of boolean properties are: `true`, `false`.

### Properties of type `int`

#### Definition

Integer properties are specified in schema files as follows:

    <name>:
        type: int

#### Usage

Assume we were to write a Consonant schema for a kanban system. Kanban
cards might have an optional `estimated-days` property to estimate the
amount of days needed to finish the corresponding tasks. The resulting
schema would look as follows:

    uuid: org.myproject.kanban.schema.1
    classes:
        card:
            properties:
                doable:
                    type: boolean
                estimated-days:
                    type: int
                    optional: true

Any card (e.g. `/card/C105`) might have this property set, resulting in
`properties.yaml` files like the following:

    estimated-days: 3
    doable: false

The above includes the `doable` property from the boolean property
example to demonstrate how a `properties.yaml` file with multiple
properties would look like.

#### Values

All `int` properties are 64 bit integers with allowed values ranging
from -9,223,372,036,854,775,808 to +9,223,372,036,854,775,807.

### Properties of type `float`

#### Definition

Floating point properties are specified in schema files as follows:

    <name>:
        type: float

#### Usage

Assume we were to write a Consonant schema for a personal finance
system with multiple bank accounts. A bank account might have a
floating point property for the current amount of money in the
account. The resulting schema would
look as follows:

    uuid: uk.me.yourname.banking.schema.1
    classes:
        account:
            properties:
                current-amount:
                    type: float

Every account (e.g. `/account/savings`) would have to have this
property set, resulting in `properties.yaml` files like the
following:

    current-amount: 159.27

#### Values

All floating point properties support double precision values.

### Properties of type `text`

#### Definition

Text properties are defined in schemas as follows:

    <name>:
        type: text

They may optionally include a regular expression as a validation
requirement for implementations:

    <name>:
        type: text
        regex: <regular expression>

#### Usage

Assume we were to define a Consonant schema for a kanban system that
includes lanes with a title, an optional description and a CSS color.
The schema for this might look as follows:

    uuid: org.yourproject.kanban.schema.1
    classes:
        lane:
            properties:
                title:
                    type: text
                description:
                    type: text
                color:
                    type: text
                    regex: ^#([0-9abcdefABCDEF]{2}){3}$

Lanes in the store would now have `properties.yaml` files like the
following:

    title: Doing
    description: |
      Tasks that are currently being worked on
      by a member of the project.
    color: #a7d239

#### Values

Text properties can store arbitrary text including whitespace that is
preserved by the store. If a `regex` validation rule is defined, the
text must in addition satisfy the given regular expression.

### Properties of type `reference`

#### Definition

Reference properties are used to describe references from one object
to another. References may be internal (within the same store) or
external (to objects in a different store). References may also include
a particular target tree or commit (again, in the same or a different
store). Another feature of object references in Consonant is that they
can be unidirectional or bidirectional.

Internal reference properties are defined as follows:

    <name>:
        type: reference
        class: <target class name>

Reference properties for linking to objects in another store are
defined by adding a schema UUID to the property definition:

    <name>:
        type: reference
        class: <target class name>
        schema: <schema UUID>

Note that the above only specifies the schema, allowing Consonant
implementations to locate the class definition of referenced objects
from the schema the UUID is resolved to. The schema does not specify
in which store(s) the referenced external objects are held. This
is purely encoded in the actual property values and may vary from
store to store.

The above definitions define one-way/unidirectional object references.
The `bidirectional` hint may be used to define bidirectional
references. The value of `bidirectional` is the name of a property
of the referenced objects that is expected to hold a reference in
the other direction. Note that property pointed at by `bidirectional`
may be a list, allowing not just one-to-one bidirectional references
but also one-to-many or many-to-many relationships to be defined:

    <name>:
        type: reference
        class: <target class name>
        bidirectional: <property name of the target class>

Note: Bidirectional properties are only supported for *internal*
references, not for references to objects in another store.

#### Usage

Assume that we were to define a schema for a kanban system with lanes
and cards, where lanes and cards have a one-to-many relationship and
cards may optionally refer to external issue objects in an issue
tracker. The kanban schema for this could include the following:

    uuid: org.yourproject.kanban.schema.1
    classes:
        lane:
            properties:
                title: text
                cards:
                    type: list
                    elements:
                        type: reference
                        class: card
                        bidirectional: lane
        card:
            properties:
                title: text
                lane:
                    type: reference
                    class: lane
                    bidirectional: cards
                issue:
                    type: reference
                    class: issue
                    schema: org.yourproject.issues.schema.1
                    optional: true

With this, every lane in the kanban store would have to have a list of
the cards in the lane in the `cards` property. An example could be the
`properties.yaml` file of a lane with the UUID `doing`:

    title: Doing
    cards:
        - C930
        - C984
        - C312

Cards on the other hand would have to have a reference back to the
lane they are in via the `lane` property` and could additional store
a reference to an external issue:

    title: Fix bug #5942
    lane: doing
    issue:
        service: issues
        uuid: bug209

where `issues` is a service alias for the issue tracker defined in
`consonant.yaml` and `bug209` is the UUID of an issue in this issue
tracker.

#### Values

The format and allowed content of references depends on whether they
are internal or external. Internal references are specified in one of
the following two ways:

* `<object UUID>`: the target object's UUID or
* a dictionary with two keys:
    - `ref`: a Git ref, tree, commit or tag of the Consonant store and
    - `uuid`: the target object's UUID.

Similarly, external references are specified via a dictionary with
the following keys:

* `service`: a service alias resolved via the `consonant.yaml` file of
  the store,
* `uuid`: the UUID of the referenced object, and
* `ref`: a Git ref, tree, commit or tag of the target Consonant store
  (optional).

### Properties of type `list`

#### Definition

List properties are defined in schemas as follows:

    <name>:
        type: list
        elements:
            <type definition for elements>

One example would be a list of lists of strings:

    <name>:
        type: list
        elements:
            type: list
            elements:
                type: string

Lists are required to always contain at least one element. The
`optional` flag can be used to define list properties that may be empty
(by not being set at at all).

#### Usage

Assume we were to define a Consonant schema for a kanban system with
lanes and cards. Assume further that lanes maintain a list of references
to the cards in them. The resulting schema might look like this:

    uuid: org.yourproject.kanban.schema.1
    classes:
        lane:
            properties:
                title: string
                cards:
                    type: list
                    elements:
                        type: reference
                        class: card
                optional: true
        card:
            ...

A "backlog" lane with three cards could then have the following content
in `properties.yaml`:

    title: Backlog
    cards:
        - C198
        - C503
        - C93

#### Values

If present in `properties.yaml` files, lists must be non-empty. Empty
list properties are realised through the `optional` flag. The allowed
values of list elements depend entirely on the element data type
specified.

### Example schemas

#### Example kanban schema

The following example schema defines all object classes and relations
necessary for a simple Kanban system. It includes:

* users,
* views (different perspectives on a subset of the lanes),
* lanes (ordered lists of cards),
* milestones (deadlines cards can be associated with),
* cards (small tasks assigned to one or more users, organised
  in lanes),
* comments (for cards) and tags (for cards and milestones).

This is pretty elaborate already. All it takes to define the above
classes and link them together is this:

    uuid: org.yourproject.kanban.schema.1
    classes:
      user:
        properties:
          name:
            type: text
          email:
            type: text
      view:
        properties:
          title:
            type: text
          description:
            type: text
          lanes:
            type: list
            elements:
              type: reference
              class: lane
              bidirectional: views
      lane:
        properties:
          title:
            type: text
          description:
            type: text
          color:
            type: text
            regex: ^([0-9abcdefABCDEF]{2}){3}$
          views:
            type: list
            elements:
              type: reference
              class: view
              bidirectional: lanes
          cards:
            type: list
            elements:
              type: reference
              class: card
              bidirectional: lanes
      milestone:
        properties:
          title:
            type: text
          description:
            type: text
          color:
            type: text
            regex: ^([0-9abcdefABCDEF]{2}){3}$
          deadline:
            type: text
            regex: ^[0-9]{4}-[0-9]{2}-[0-9]{2}$
          cards:
            type: list
            elements:
              type: reference
              class: card
              bidirectional: lanes
          tags:
            type: list
            elements:
              type: reference
              class: tag
      card:
        properties:
          title:
            type: text
          description:
            type: text
          estimate:
            type: int
          lane:
            type: reference
            class: lane
            bidirectional: cards
          milestone:
            type: reference
            class: milestone
            bidirectional: cards
          assignees:
            type: list
            elements:
              type: reference
              class: user
          comments:
            type: list
            elements:
              type: reference
              class: comment
          tags:
            type: list
            elements:
              type: reference
              class: tag
      comment:
        properties:
          author:
            type: reference
            class: user
          text:
            type: text
      tag:
        properties:
          title:
            type: text
          description:
            type: text

#### Example issues schema

TODO

# Consonant services / data interface

<!--
## Object References

TODO

Three types:

1. Internal: `<UUID>`
2. Simple external: `<prefix>:<UUID>` (e.g. `kanban:S1234`)
3. Advanced external: `<prefix>@<ref>:<UUID>` (e.g. `kanban@master:S1234`)

Web API convention for resolving links:

* `GET /gitstore/api/1.0/resolve/<UUID>/<ref>`
* e.g. `GET /gitstore/api/1.0/resolve/S1234/master`
* HTTP response codes:
    - 404 - not found
    - 302 - found, redirecting to service-specific link (e.g.
      <http://kanban.foo.org/card/S1234>)
    - 351 (?) - multiple choices, i.e., ambiguous ref

## Example Object Store Tree

TODO

# RESTful Web API for Object Stores

TODO

# Linking Object Stores Together

TODO

Config file to register local or remote stores (`~/.gitstore.conf`):

    <UUID>: <local path or http:// URL>
    <UUID>: <local path or http:// URL>

# Python Base Library

TODO

Have a Python base library that

* implements the data model based on pygit2 in a generic way
* can spin up a RESTful web service to query and modify a given data
  store
* allows hooks for UUID generation, authentication, authorisation etc.
  to develop an LDAP authentication layer and specific web applications
  for different services (MUSTARD, Kanban) on top:

        /gitstore/api/1.0/resolve/...
        /gitstore/api/1.0/create/...
        /gitstore/api/1.0/delete/...
        /gitstore/api/1.0/hide/...
        /gitstore/api/1.0/modify/...
* uses <http://sendapatch.se/projects/pylibmc/> for caching parsed YAML
  blobs (which is the thing that is likely to slow things down most)
-->
