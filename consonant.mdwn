% Consonant Specification, Version 0.0
% Daniel Silverstone (<daniel.silverstone@codethink.co.uk>);
  Jannis Pohlmann (<jannis.pohlmann@codethink.co.uk>)
% July 19th, 2013

# Introduction

## What is Consonant?

*Consonant* is an object-relational, cross-referenced, verifiable and
service-oriented Git object store and corresponding web API. It is named
after the adjective *consonant* ("characterized by harmony or
agreement"), reflecting its focus on a unified data model and
cross-store referencing and validation.

Consonant is the name given to the overall design. Any implementation
that implements this specification, i.e. uses the same data model and
provides the same API, may call itself a "Consonant implementation".

## Motivation

One of the key aspects of our recent work on Baserock and other projects
has been what we call *traceability*—the ability to tell how data
changed over time, who changed what and why, and how the data in
question looked like at a specific point in time.

Two examples are:

* The requirements and architecture of projects change over time. In
  this context it is often beneficial to know who approved changes when
  and how the planned work changed over time.
* Kanban is a popular solution for organising work of teams. When
  assessing project productivity and progress, it is essential to have
  ways of telling how a kanban changed over time, e.g. how many cards
  were moved in a day or a week. Among other things this helps
  understanding how realistic milestones are.

## Key concepts

In order to support the development of applications that need traceable
data stores, we have identified the need for the following:

* A generic object store in Git:
    - object-relational,
    - database-like,
    - versioned,
    - branchable,
    - versatile.
* Representation of objects as YAML files:
    - unique IDs,
    - properties,
    - readable and editable by humans and machines alike,
    - plain text, useful for diffs.
* References between objects in different data stores:
    - verifiable,
    - versioned.
* Service-oriented design to allow rapid development of interconnected
  web applications on top of Git object stores.

Consonant aims to satisfy this demand by specifying

* a Git/YAML based data model with schemas for type checking and
  validation,
* a RESTful web service API for querying and modifying git object
  stores,
* a mechanism to for referencing objects across git object stores.

## Why not use an existing database?

There are a number of reasons for choosing Git over existing relational
or NoSQL databases. Like NoSQL databases, Git is—at its core—a
key-value store for arbitrary data. On top of this, Git offers
versioning, branching and merging, transactions (commits),
de-duplication, offline work and authorship information out of the box,
whereas with other databases you would have to implement a lot of this
yourself.

## Terminology

* A `Consonant store` is a Git repository that follows the Consonant
  data model.
* A `Consonant service` is a service that provides access to a
  Consonant store via the standard RESTful Consonant web API.
* A `Consonant register` is a local mapping of schema and store UUIDs
  to Consonant services.
* A `Consonant schema` is a YAML file defining classes for objects with
  typed properties.

# Consonant stores / data model

Representing arbitrary objects in Git requires a unified data model,
allowing different software implementions to access and modify these
objects in a compatible way. This section describes the data model for
Consonant stores.

The central elements of the data model specified in the following
sections are:

* store repositories and store imports,
* schemas and schema imports,
* classes,
* objects,
* properties,
* attachments.

## Store repository

Every Consonant store is a Git repository. As such it is represented as
a directory that holds the Git key/value store and that can (usually)
be accessed remotely via different protocols. The Git key/value store
consists of data that is addressed by a SHA1 of its content. The
following data elements exist in Git:

* `blob`: a file with specific content,
* `tree`: a directory of specific trees and blobs,
* `commit`: a specific tree, annotated with a list of parent commits
  and other meta data, such as author, committer, commit message and
  so on.

All of the above are stored in Git based on the SHA1 of their contents.
Two files with the same content would result in a single blob that may
be referenced by different trees. Two commits that have the same parents
and introduce the same changes will result in two different commit
elements that reference the same tree (with the modifications made) and
so on.

In addition to the above, heads (flexible, often refered to as branches)
and tags (fixed) can be used to point to specific commits (and therefore
the complete history of a Git tree).

Together this provides the underlying storage mechanism for Consonant
stores.

## Trees and their structure

Each Git tree (associated with a commit or not) represents a particular
version or revision of the store's data. The following elements are
present in a tree:

1. A top-level `consonant.yaml` file that contains
    - the store UUID,
    - a reference to the schema defining the object classes used in
      the store,
    - a set of aliased references to external services for
      cross-linking.
2. One top-level directory for each object class for which objects
   have been created (e.g. `/card/`, `/lane/`, `/user/`).
3. One directory in the corresponding object class directory for
   each object that has been created (e.g. `/card/C1234/`,
   `/lane/backlog/`).
4. One `properties.yaml` file in each object directory, storing the
   properties of the object.
5. An optional `attachments/` directory inside each object directory,
   holding arbitrary attachments in pairs of `attachments/<name>` and
   `attachments/.<name>.yaml` files, the latter storing attachment meta
   data.

### Example tree

This is how an example tree for a simple kanban system could look like:

    consonant.yaml
    lane/
        backlog/
            properties.yaml
        doing/
            properties.yaml
        done/
            properties.yaml
    card/
        C1234/
            properties.yaml
                attachments/
                    foo.txt
                    .foo.txt.yaml
                    bar.png
                    .bar.png.yaml
        .C5123/
            properties.yaml

## The `consonant.yaml` file

This file defines the unique ID (UUID) and structure of the store as
well as external stores that objects are or may be linking to.

It is a YAML file with three top-level keys:

1. `uuid`: Defines the unique ID (UUID) of the store. The format of
   store UUIDs is specified in the *UUIDs* section.
2. `schema`: A schema reference stating the schema being used in the
   store. This schema defines the object classes available in the store
   and specifies names and types of object properties. For the format
   of schema references see *Schema references*.
3. `services`: A dictionary mapping (preferably short) aliases to
   service references, allowing short and readable cross-references to
   objects in external stores. The exact format of service references
   is specified in *Service references*.

### Schema references

Schema references are strings in one of the following formats,
referencing local or remote schemas:

1. `<schema UUID>`: Reference to a schema by UUID. This reference is
   resolved via the consonant register (see the *Consonant register*
   section).
2. `http://url.of.a.consonant.service/`: HTTP URL of a Consonant
   service. The Consonant web API supports querying the schema being
   used in a store, allowing services to be linked together remotely
   and in flexible ways.
3. `http://url.to.a/schema.yaml`: HTTP URL to a remote schema file.
4. `file:///path/to/a/schema.yaml`: Path to a local schema file.

### Service references

Service references are strings in one of the following formats,
referencing external Consonant services.

1. `<service UUID>`: Reference to a service by UUID. This reference is
   resolved via the consonant register (see the *Consonant register*
   section).
2. `http://url.of.a.consonant.store/`: HTTP URL of a Consonant service.

### Example `consonant.yaml` file

The following example shows a hypothetical `consonant.yaml` file for
a kanban system that uses its own schema and supports cross-references
to a bug tracking system built on top of Consonant.

    uuid: org.yourproject.kanban.store
    schemas:
        - org.yourproject.kanban.schema
    stores:
        bugs: http://bugs.yourproject.org/

## Object class directories

Each class for which objects have been created in a Consonant store is
represented by a top-level directory that is named after the class name.
The class name in turn is defined by one of the schema listed in the
store's `consonant.yaml` file.

Examples are `/card/`, `/lane/`, `/milestone/` for card, lane and
milestone objects in a kanban system or `/project/`, `/component/` and
`/issue/` for project, component and issue objects in a bug tracker.

## Object directories

Each object created in a Consonant store is represented by an object
directory inside the corresponding class directory. Object directories
are named after object UUIDs.

Examples are `/card/C423/` (for a kanban card with the number 423),
`/lane/backlog/` (for a backlog lane in a kanban system) and
`/milestone/15/` (for the 15th milestone defined in a project).

The format of object UUIDs may vary and is specified in one of the
schema used by the store (see the *Schemas* section for more details).

Objects would be useless if all they consisted of was a class and a
name. Like in many programming languages, Consonant objects have
so-called properties. They come in three variants:

1. a special property to hide objects,
2. properties specified by schemas and defined in `properties.yaml`
   files,
3. arbitrary data properties called *attachments*.

### Hidden objects

A special feature of Consonant stores is that objects can be hidden by
prepending their directory name with a dot (e.g. `/card/.C503/`). This
is similar to hiding files on file systems.

Hidden objects are not parsed and loaded into memory unless explicitly
requested. Depending on the amount of data, this can result in
significant performance boosts. However, hidden objects still remain
present in the store so that their existence and history can be
detected without having to locate them in the revision history of
the entire store.

Hiding files can have different semantic benefits. One example would
be "archiving" cards in a kanban system in order to mark them as
obsolete while at the same time preserving a view of all archived
cards for project managers and statistics.

### The `properties.yaml` file

The `properties.yaml` files contain the mandatory and optional
properties for individual objects. There is one file for each object,
located in the object directory (e.g. `/card/C593/properties.yaml`).

Like the file extension suggests, `properties.yaml` files are YAML
files. They each hold a flat dictionary that maps property names to
property values. The data types supported for properties are explained
in the *Schemas* section.

#### Example `properties.yaml` file

The following example shows a hypothetical `properties.yaml` file for
a lane in a kanban system, including the properties `name` (string),
`description` (text, multi-line), `color` (string), `cards` (list of
internal references to objects of the class `card`).

    name: Doing
    description: |
      Tasks that are currently being worked on.
    color: #ffa500
    cards:
      - C513
      - C506
      - C654

### The `attachments` directory

In addition to regular properties that are defined by schemas, each
object may store arbitrary properties called *attachments*. These are
stored as pairs of files in an `attachments/` subdirectory inside the
object directory (e.g. `/card/C854/attachments/`).

Attachments consist of a name (e.g. `comments` or `mockup.png`),
the actual data and arbitrary YAML meta data. All this is stored in
the `attachments/` directory as follows:

1. `attachments/NAME`: holds the attachment data,
2. `attachments/.NAME.yaml`: holds the attachment meta data,

where `NAME` is the name of the attachment.

#### Example `attachments` directory

The following example shows a hypothetical listing of an attachments
directory for issue `6031` in a bug tracker:

    /issue/6031/attachments/patch-v1.patch
    /issue/6031/attachments/.patch-v1.patch.yaml
    /issue/6031/attachments/patch-v2.patch
    /issue/6031/attachments/.patch-v2.patch.yaml

The YAML meta data in `.patch-v1.patch.yaml` could look like this:

    description: |
      This patch is a first attempt at fixing issue 6031. It is
      caused by accidently overwriting the value of `foo` in the
      for-loop in `bla.c`.
    patch: true
    content-type: text/plain

## UUIDs

TODO

## The Consonant register

The *Consonant register* is a special configuration file that allows
to register Consonant stores and schemas system-wide or per-user. It is
is used to resolve UUID-based schema and store imports in
`consonant.yaml`.

The system-wide and per-user register is located according to the
[XDG Base Directory Specification](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html),
that is, the system-wide register is stored in
`$XDG_CONFIG_DIRS/consonant/register.yaml`, the per-user register is
stored in `$XDG_CONFIG_HOME/consonant/register.yaml`.

Registry files are YAML files that contain the following two keys:

1. `schemas`: a dictionary mapping schema UUIDs to fully qualified
   schema locations (HTTP schema query URLs, local store
   repositories or or local schema files).
2. `stores`: a dictionary mapping store UUIDs to fully qualified store
   locations (HTTP service URLs or local store repositories).

Whenever a schema or store UUID mapping appears in the system-wide
register *and* the per-user register, the mapping the user register
takes precedence and overrides the system-wide mapping.

### Example register

The following examples shows a hypothetical system and user register
defining mappings for schemas and stores for a kanban and bug tracking
system. The user mapping for the bug tracker overrides the system-wide
setting.

System register:

    schemas:
        org.project.kanban.schema: http://kanban.project.org/
        org.project.bugs.schema:   http://bugs.project.org/
    stores:
        org.project.kanban.store:  http://kanban.project.org/
        org.project.bugs.store:    http://bugs.project.org/

Registry of user `jeff`:

    stores:
        org.project.bugs.store:    /home/jeff/project/bugs/

## Schemas

# Consonant services / data interface

<!--
## Store, Schema and Object UUIDs

UUIDs for stores and schemas are required to be globally unique and
follow the following format:

([a-zA-Z_]{1}[a-zA-Z0-9_]*(\.[a-zA-Z_]{1}[a-zA-Z0-9_]*)*)?

This is similar to how D-Bus names and JAVA packages/classes are
specified. A few examples of store and schema UUIDs are:

	  org.myproject.stores.kanban
    org.myproject.stores.requirements
    org.myproject.schemas.kanban
    org.myproject.schemas.requirements

A versioning scheme is recommended if there are different, incompatible
versions of stores and schemas, e.g.

	  org.myproject.schemas.kanban
    org.myproject.schemas.kanban1
    org.myproject.schemas.kanban2

but this is not mandatory.

UUIDs for objects are required to be unique within a store and follow
the following format:

    (^[:\/])+

Example object UUIDs are:

    Kanban cards: K10, K512, K1253
    Issues: 5940, 234
    Customers: uk.co.codethink, org.company.division

## Schemas

Schemas are files that describe the object classes available for use in
an object store. Definitions of classes include a class name and a list
of properties. Each property definition includes a name, basic data type
and data type specific information (e.g. for validating strings).
Properties may also be marked optional via the `optional=<true|false>`
field.

The following basic data types are supported:

+------------+--------------------------------------+-----------------------------------------------------+
| Name       | Description                          | Extra fields                                        |
+============+======================================+=====================================================+
| string     | A single line of text.               |                                                     |
+------------+--------------------------------------+-----------------------------------------------------+
| regex      | A regular expression for validating  |                                                     |
|            | the value of a string property       |                                                     |
+------------+--------------------------------------+-----------------------------------------------------+
| text       | Multiple lines of text.              |                                                     |
+------------+--------------------------------------+-----------------------------------------------------+
| list       | List of values of another data type. | * type - basic data type of list elements           |
+------------+--------------------------------------+-----------------------------------------------------+
| ref        | Reference to another object.         | * *class* - name of the class of referenced objects |
|            |                                      | * *store* - alias, UUID, path or URL to an HTTP     |
|            |                                      |   object store service that the holds the           |
|            |                                      |   referenced objects                                |
+------------+--------------------------------------+-----------------------------------------------------+

Table: Data types supported by the generic Git object store.

An example schema could look as follows

    org.myproject.schemas.kanban.yaml:
    uuid: org.myproject.schemas.kanban
        lane:
            title:
                kind: string
                regex: ^.*$
            cards:
                kind: list
                type: ref
                class: card
            colour:
                kind: string
                regex: ^#([0-9abcdefABCDEF]{6})$
        card:
            issue:
                kind: ref
                class: issue
                store: issues
                optional: true

An example schema file called `org.myproject.schemas.kanban` could look
as follows

    uuid: org.myproject.schemas.kanban
        lane:
            title:
                kind: string
                regex: ^.*$
            cards:
                kind: list
                type: ref
                class: card
            colour:
                kind: string
                regex: ^#([0-9abcdefABCDEF]{6})$
        card:
            issue:
                kind: ref
                class: issue
                store: issues
                optional: true

## Object References

TODO

Three types:

1. Internal: `<UUID>`
2. Simple external: `<prefix>:<UUID>` (e.g. `kanban:S1234`)
3. Advanced external: `<prefix>@<ref>:<UUID>` (e.g. `kanban@master:S1234`)

Web API convention for resolving links:

* `GET /gitstore/api/1.0/resolve/<UUID>/<ref>`
* e.g. `GET /gitstore/api/1.0/resolve/S1234/master`
* HTTP response codes:
    - 404 - not found
    - 302 - found, redirecting to service-specific link (e.g.
      <http://kanban.foo.org/card/S1234>)
    - 351 (?) - multiple choices, i.e., ambiguous ref

## Example Object Store Tree

TODO

# RESTful Web API for Object Stores

TODO

# Linking Object Stores Together

TODO

Config file to register local or remote stores (`~/.gitstore.conf`):

    <UUID>: <local path or http:// URL>
    <UUID>: <local path or http:// URL>

# Python Base Library

TODO

Have a Python base library that

* implements the data model based on pygit2 in a generic way
* can spin up a RESTful web service to query and modify a given data
  store
* allows hooks for UUID generation, authentication, authorisation etc.
  to develop an LDAP authentication layer and specific web applications
  for different services (MUSTARD, Kanban) on top:

        /gitstore/api/1.0/resolve/...
        /gitstore/api/1.0/create/...
        /gitstore/api/1.0/delete/...
        /gitstore/api/1.0/hide/...
        /gitstore/api/1.0/modify/...
* uses <http://sendapatch.se/projects/pylibmc/> for caching parsed YAML
  blobs (which is the thing that is likely to slow things down most)
-->
