% Consonant Specification, Version 0.0
% Daniel Silverstone (<daniel.silverstone@codethink.co.uk>);
  Jannis Pohlmann (<jannis.pohlmann@codethink.co.uk>)
% July 26th, 2013

# Issues to fix

* What if the `consonant.yaml` file changes over time. What if the
  schema being used changes incompatibly or the `consonant.yaml` file
  out of a sudden points to a different version of a schema?
  What if the UUID changes? What if the schema is different between
  different branches of a store?
* Do we know that Git copes well with trees that have thousands of
  entries? Hack up a test repository and run something with pygit2
  against it.
* We need to define that bidirectional references may only define
  pairs, not triangles etc.
* We should probably separate the data model and the data interface
  into separate specifications. The web API might change and advance
  to another version independently of the data model.
* The web API does not have a feature for including hidden objects,
  e.g. via a `?hidden=true` filter.
* The HTTP response code behavior is not documented yet.
* We might want to define a common YAML/JSON body for error responses;
  this is particularly important for transactions of course but also
  for read methods where you might want to know what doesn't exist:
  the class, the object in the class or the property that you've asked
  for.
* Do we want to support pagination when requesting a lot of objects?
* The mandatory `content-type` property for attachment meta data is not
  not documented yet.
* The `POST /transaction` API needs additional transaction header
  fields like "author" and "message".

# Introduction

## What is Consonant?

*Consonant* is an object-relational, cross-referenced, verifiable and
service-oriented Git object store and corresponding web API. It is named
after the adjective *consonant* ("characterized by harmony or
agreement"), reflecting its focus on a unified data model and
cross-store referencing and validation.

Consonant is the name given to the overall design. Any implementation
that implements this specification, i.e. uses the same data model and
provides the same API, may call itself a "Consonant implementation".

## Motivation

One of the key aspects of our recent work on Baserock and other projects
has been something we call *traceability*—the ability to tell how data
changed over time, who changed what and why, and how the data in
question looked like at a specific point in time.

Examples are:

* The requirements and architecture of projects tend to change over
  time. In this context it is often beneficial to understand who
  approved changes when and how the planned work changed over time.
* Kanban is a popular solution for organising work of teams. When
  assessing project productivity and progress, it is essential to have
  ways of telling how a kanban changed over time, e.g. how many cards
  were moved in a day or a week or how the cards linked to a milestone
  have changed from week to week. Among other things this helps
  understanding how realistic milestones are and whether adjustments
  have to be made.

## Key concepts

In order to support the development of applications that need traceable
data stores, we have identified the need for the following:

* A generic object store in Git:
    - object-relational,
    - database-like,
    - versioned,
    - branchable,
    - versatile.
* Representation of objects as YAML files:
    - unique IDs,
    - properties,
    - readable and editable by humans and machines alike,
    - plain text, useful for diffs.
* References between objects in different data stores:
    - verifiable,
    - versioned.
* Service-oriented design to allow rapid development of interconnected
  web applications on top of Git object stores.

Consonant aims to satisfy these demands by specifying

* a Git/YAML based data model with schemas for type checking and
  validation,
* a standard web API for querying and modifying object stores based on
  this data model,
* a mechanism for referencing objects across different stores.

## Why not use an existing database?

There are a number of reasons for choosing Git over existing relational
or NoSQL databases. Like NoSQL databases, Git is—at its core—a
key-value store for arbitrary data. On top of this, Git offers
versioning, branching and merging, transactions (commits),
de-duplication, offline work and authorship information out of the box,
whereas with other databases you would have to implement a lot of this
yourself.

## Offline stores

TODO

Describe the importance of being able to take stores off-line.

## Terminology

This specification aims to use consistent terms for the different
aspects of the Consonant design.

* A *Consonant store* is a Git repository whose contents follows the
  Consonant data model.
* A *Consonant service* is a service that provides access to a
  Consonant store via the Consonant web API.
* A *Consonant register* is a YAML file that maps Consonant schema and
  service UUIDs to Consonant services.
* A *Consonant schema* is a YAML file that defines classes for objects
  with typed properties.

# Consonant stores / data model

Representing arbitrary objects in Git requires a unified data model,
allowing different software implementions to access and modify these
objects in a compatible way. This section describes the data model for
Consonant stores.

The central elements of the data model specified in the following
sections are:

* store repositories and service references,
* schemas and schema references,
* classes,
* objects,
* properties,
* attachments.

## Store repository

Every Consonant store is a Git repository. As such it is typically
represented as a directory that holds the Git key/value store and
that can (usually) be accessed remotely via different protocols.
The Git key/value store consists of data that is addressed by a
SHA1 of its content. The following data elements exist in Git and
are relevant to Consonant:

* *blob*: a file with specific content,
* *tree*: a directory of specific subtrees and blobs,
* *commit*: a specific tree, annotated with a list of parent commits
  and other meta data, such as author, committer, commit message and
  so on.

All of the above are stored in Git based on the SHA1 of their contents.
Two files with the same content would result in a single blob that may
be referenced by different trees. Two commits that have the same parents
and introduce the same changes will result in two different commit
elements that reference the same tree (with the modifications made) and
so on.

In addition to the above, heads (flexible, often refered to as branches)
and tags (fixed) can be used to point to specific commits (and therefore
the complete history of a Git tree).

Together this provides the underlying storage mechanism for Consonant
stores.

## Trees and their structure

From here on, *tree* refers to the fully resolved tree of trees
normally associated with a Git commit. Each tree, whether associated
with a commit or not, represents a particular version or revision of
the store's data. The following elements are present in a tree:

1. A top-level `consonant.yaml` file that contains
    - the store UUID,
    - a reference to the schema defining the object classes used in
      the store,
    - a set of aliased references to external services for
      cross-linking.
2. One top-level directory for each object class for which objects
   have been created (e.g. `/card/`, `/lane/`, `/user/`).
3. One directory in the corresponding object class directory for
   each object that has been created (e.g.
   `/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270/`).
4. One `properties.yaml` file in each object directory, storing the
   properties of the object.
5. An optional `attachments/` directory inside each object directory,
   holding arbitrary attachments in pairs of `attachments/<name>` and
   `attachments/.<name>.yaml` files, the latter storing attachment meta
   data.

### Example tree

This is how an example tree for a simple kanban system could look like:

    consonant.yaml
    lane/
        9f03afc6-20c3-4757-a671-2bcdccd47f46/
            properties.yaml                   # title: Backlog
        6453247f-4aed-4233-bf5a-51e056d9f080/
            properties.yaml                   # title: Doing
        8c5bba15-8f70-486a-89fc-fa5a964ee624/
            properties.yaml                   # title: Done
    card/
        0cca0d5f-25a2-4b2f-a8ad-7f647aedb2df/
            properties.yaml                   # number: 129
            attachments/
                foo.txt
                .foo.txt.yaml
                bar.png
                .bar.png.yaml
        .f59d7c0b-ddac-429d-820b-9867794a9a93/
            properties.yaml                   # number: 483

## The `consonant.yaml` file

This file defines the universally unique ID (UUID) and structure of
the store as well as external stores that objects are or may be
linking to.

It is a YAML file with three top-level keys:

1. `uuid`: Defines the unique ID of the store. The format of store
   UUIDs is specified in the *UUIDs* section.
2. `schema`: A schema reference stating the schema being used in the
   store. This schema defines the object classes available in the store
   and specifies names and types of object properties. For the format
   of schema references see *Schema references*.
3. `services`: A dictionary mapping (preferably short) aliases to
   service references, allowing short and readable cross-references to
   objects in external stores. The exact format of service references
   is specified in *Service references*.

### Schema references

Schema references are strings in one of the following formats,
referencing local or remote schemas:

1. `<schema UUID>`: Reference to a schema by UUID. This reference is
   resolved via the Consonant register (see the *Consonant register*
   section).
2. `<scheme>://<url to a schema>`: URL to a schema file. Implementations
   are required to support `http`, `https` and `file` URLs.

### Service references

Service references are strings in one of the following formats,
referencing external Consonant services.

1. `<service UUID>`: Reference to a service by UUID. This reference is
   resolved via the consonant register (see the *Consonant register*
   section).
2. `<scheme>://<url to a service>`: URL to a Consonant service.
   Implementations are required to support `http`, `https` and `file`
   URLs. `file` URLs specify local Consonant stores rather than service
   end points, which implies that implementations resolving `file` URLs
   need to be able to activate services for these stores on demand.

### Example `consonant.yaml` file

The following example shows a hypothetical `consonant.yaml` file for
a kanban system that uses its own schema and supports cross-references
to a bug tracking system built on top of Consonant.

    uuid: org.yourproject.kanban.store
    schema: org.yourproject.kanban.schema.1
    stores:
        issues: http://issues.yourproject.org/

## Object classes

Object classes are defined by the schema used in a Consonant store.
Each class for which objects have been created is represented by
a top-level directory that is named after the name of the class, as
specified in the store's schema.

Examples are `/card/`, `/lane/`, `/milestone/` for card, lane and
milestone objects in a kanban system or `/project/`, `/component/` and
`/issue/` for project, component and issue objects in a bug tracker.

## Objects

Each object created in a Consonant store is represented by an object
directory inside the corresponding class directory. Object directories
are named after object UUIDs. The format of object UUIDs is described
in the *Object UUIDs* section.

Examples of object directories in a Consonant tree are

* `/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270/`,
* `/lane/c675a494-9616-41aa-9833-5629029f6c41/`, or
* `/milestone/a64c6577-e810-4d7b-922c-2a94c3dd644b/`.

Objects would be useless if all they consisted of was a class and a
name. Like in many programming languages, Consonant objects have
so-called properties. They come in three variants:

1. a special property to hide objects,
2. properties specified by schemas and set in `properties.yaml` files,
3. arbitrary data properties called *attachments*.

### Hidden objects

A feature of Consonant stores is that objects can be hidden by
prepending a dot to their directory name (e.g.
`/card/.3652ccf3-0aa3-4974-88a3-37cd8b74a270/`). This is similar to
marking files as hidden in a file system.

Hidden objects are not parsed and loaded into memory unless explicitly
requested. Depending on the amount of data, this can result in
significant performance boosts. However, hidden objects still remain
present in the store so that their existence and history can be
determined without having to locate them in the revision history of
the entire store.

Hiding files can have different semantic meanings. One example would
be "archiving" cards in a kanban system in order to mark them as
obsolete while at the same time preserving a view of all archived
cards for project managers and statistics.

### The `properties.yaml` file

The `properties.yaml` files contain the mandatory and optional
properties for individual objects. There is one file for each object,
located in the object directory (e.g.
`/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270/properties.yaml`).

Like the file extension suggests, `properties.yaml` files are YAML
files. They each hold a flat dictionary that maps property names to
property values. The data types supported for properties are explained
in the *Schemas* section.

#### Example `properties.yaml` file

The following example shows a hypothetical `properties.yaml` file for
a lane in a kanban system, including the properties `name` (text),
`description`, `color` (text), `cards` (list of internal references
to objects of the class `card`).

    title: Doing
    description: |
        Tasks that are currently being worked on. Cards are
        being moved here from the "Backlog" and are moved to
        "Done" after being processed.
    color: #ffa500
    cards:
        - uuid: 3652ccf3-0aa3-4974-88a3-37cd8b74a270
        - uuid: 1b1f1146-72c5-4890-9501-068ddb0560be
        - uuid: 2066c664-a8fe-494f-bddf-756be267fb3c

### The `attachments` directory

In addition to regular properties that are defined in schemas, each
object may store arbitrary properties called *attachments*. These are
stored as pairs of files in an `attachments/` subdirectory inside the
object directory (e.g.
`/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270/attachments/`).

Attachments consist of a name (e.g. `comments` or `mockup.png`),
the actual data and arbitrary YAML meta data. All this is stored in
the `attachments/` directory as follows:

1. `attachments/NAME`: holds the attachment data,
2. `attachments/.NAME.yaml`: holds the attachment meta data,

where `NAME` is the name of the attachment. Attachment names may
not start with a dot and may not contain slashes. Unlike object
properties that are validated via Consonant schemas, there is no
defined validation scheme for attachment meta data. This is entirely
left up to applications built with Consonant.

#### Example `attachments` directory

The following example shows a hypothetical listing of an attachments
directory for issue `6031` in a bug tracker:

    /issue/5d4c394d-cb88-4d98-954f-85f17fe51948/attachments/
        patch-v1.patch
        .patch-v1.patch.yaml
        patch-v2.patch
        .patch-v2.patch.yaml

The YAML meta data in `.patch-v1.patch.yaml` could look like this:

    description: |
        This patch is a first attempt at fixing issue 6031.
        It is caused by accidently overwriting the value of
        `foo` in the for loop in `bla.c`.
    patch: true
    content-type: text/plain

## UUIDs

Universally unique identifiers (UUIDs) are being used to refer to other
objects, schemas or stores/services. Universality of identifiers is not
enforced: while creators of schemas and stores are encouraged to use
globally unique identifiers (see below), there is no way to guarantee
this. Identifiers of objects only have to be unique within a store.

### Object UUIDs

Identifiers of objects are required to be unique within a store. Their
generation is left to Consonant implementations. However, they must be
a mix of alphanumeric characters and dashes and must not begin or end
with a dash:

    ^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])$

The use of standard UUIDs (see
<http://en.wikipedia.org/wiki/Universally_unique_identifier>) is
strongly recommended.

It is mandatory that applications place no semantic meaning on object
UUIDs.

### Schema UUIDs

Identifiers of schemas are required to be of the form

    some.domain.schemaname.1

meaning that they follow a reverse domain notation similar to that used
for Java packages/classes and D-Bus service names. A special requirement
is the mandatory final segment of the UUID, which specifies the schema
version:

    ^[a-zA-Z][a-zA-Z0-9-]*(\.[a-zA-Z][a-zA-Z0-9-]*)*\.[0-9]+$

### Store/service UUIDs

Identifiers of stores/services are required to be of the form

    some.domain.storename

meaning that they follow the same reverse domain notation as schema
UUIDs except for not requiring a version number segment at the end:

    ^[a-zA-Z][a-zA-Z0-9-]*(\.[a-zA-Z][a-zA-Z0-9-]*)$

## The Consonant register

The *Consonant register* is a special configuration file that allows
to register Consonant services and schemas system-wide or per-user. It is
is used to resolve UUID-based schema and store imports in
`consonant.yaml`.

The Consonant register is located according to the
[XDG Base Directory Specification](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html),
that is, the system register is stored in

    $XDG_CONFIG_DIRS/consonant/register.yaml

and the user register is stored in

    $XDG_CONFIG_HOME/consonant/register.yaml

Register files are YAML files that contain the following two keys:

1. `schemas`: a dictionary mapping schema UUIDs and URLs to local file
   paths.
2. `services`: a dictionary mapping service UUIDs to service URLs.

Whenever the same UUID appears in both the system-wide register
and the per-user register the mapping in the user register takes
precedence and overrides the system-wide one.

### Example register

The following examples shows a hypothetical system and user register
defining mappings for schemas and stores for a kanban and bug tracking
system. The user mapping for the bug tracker overrides the system-wide
setting for a local installation of the bug tracking service (and
store).

System register:

    schemas:
        org.project.kanban.schema.1: >
            /usr/share/consonant/schemas/org.project.kanban.schema.1
        org.project.issues.schema.1: >
            /usr/share/consonant/schemas/org.project.issues.schema.1

Registry of user `jeff`:

    stores:
        org.project.issues.store: http://localhost:8080/

## Schemas

Schemas are YAML files that define the object classes available for
use in a Consonant store.

### Schema files

Schemas are defined via YAML files, of which there is one per schema.
Schema files contain the following top-level keys:

* `uuid`: the UUID of the schema (see the *Schemas* section for more
  information).
* `classes`: a mapping of class names to class definitions, each
  consisting of a set of property definitions.

### Class definitions

Classes are defined via a class name that is mapped to a set of object
property definitions inside the `classes` key in schema files.

The class name is the key the class is stored under in `classes`. Class
names are limited to alphanumeric characters mixed with dashes. They
must begin with a letter, may not end with a dash and must have a
minimum length of 2 characters:

    ^[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9]$

The `properties` key under the class definition maps object property
names to their definitions.

The following example shows (partial) hypothetical schema for a kanban
system based on Consonant, defining two classes for kanban lanes and
cards, respectively:

    uuid: org.yourproject.kanban.schema1
    classes:
        lane:
            properties:
                ...
        cards:
            properties:
                ...

### Object properties

Object properties are defined as a dictionary under the `properties`
key of class definitions. Each property definition includes

* a name,
* a data type,
* an `optional` flag, and
* data type specific hints (e.g. validation rules).

### Property names

Property names are alphanumeric strings that may contain dashes as
delimiters. Property names must start with a letter and may not end with
a dash. They must have a minimum length of 2 characters. Property
names can be validated using the following regular expression:

    ^[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9]$

Examples of valid property names are: `id`, `title`, `email-address`,
`property1`.

### Property data types

Object properties are strictly typed, meaning that each property is
associated with a data type and optional validation rules. This
information is used by Consonant implementations to validate entire
data stores.

The following table lists all data types supported by Consonant schemas.

+-------------+-------------------------------------------------------------+
| Name        | Description                                                 |
+=============+=============================================================+
| boolean     | Data type with only two possible values: `true` or `false`. |
+-------------+-------------------------------------------------------------+
| int         | Data type for 64 bit signed integers.                       |
+-------------+-------------------------------------------------------------+
| float       | Data type for double-precision floating-point numbers.      |
+-------------+-------------------------------------------------------------+
| text        | Data type for arbitrary text. Whitespace is preserved.      |
+-------------+-------------------------------------------------------------+
| reference   | Data type for references to other objects, either in the    |
|             | same or a different Consonant store.                        |
+-------------+-------------------------------------------------------------+
| list        | Data type for lists of values of another basic data type.   |
|             | Lists may be nested.                                        |
+-------------+-------------------------------------------------------------+

### Properties of type `boolean`

#### Definition

Boolean properties are specified in schema files as follows:

    <name>:
        type: boolean

#### Usage

Assume we were to write a Consonant schema for a kanban system. Kanban
cards might have a boolean property `doable` to mark them as small
tasks that can be completed in less then a day. In the schema, this
would look as follows:

    uuid: org.yourproject.kanban.schema.1
    classes:
        card:
            properties:
                doable:
                    type: boolean

A card `/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270` might have this
property set, in which case its `properties.yaml` file in the
corresponding Consonant store would look like this:

    doable: true

#### Values

Allowed values of boolean properties are: `true`, `false`.

### Properties of type `int`

#### Definition

Integer properties are specified in schema files as follows:

    <name>:
        type: int

#### Usage

Assume we were to write a Consonant schema for a kanban system. Kanban
cards might have an optional `estimated-days` property to estimate the
amount of days needed to finish the corresponding tasks. The resulting
schema would look as follows:

    uuid: org.myproject.kanban.schema.1
    classes:
        card:
            properties:
                doable:
                    type: boolean
                estimated-days:
                    type: int
                    optional: true

Any card (e.g. `/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270`) might have
this property set, resulting in `properties.yaml` files like the
following:

    estimated-days: 3
    doable: false

The above includes the `doable` property from the boolean property
example to demonstrate how a `properties.yaml` file with multiple
properties would look like.

#### Values

All `int` properties are 64 bit integers with allowed values ranging
from -9,223,372,036,854,775,808 to +9,223,372,036,854,775,807.

### Properties of type `float`

#### Definition

Floating point properties are specified in schema files as follows:

    <name>:
        type: float

#### Usage

Assume we were to write a Consonant schema for a personal finance
system with multiple bank accounts. A bank account might have a
floating point property for the current amount of money in the
account. The resulting schema would
look as follows:

    uuid: uk.me.yourname.banking.schema.1
    classes:
        account:
            properties:
                name:
                    type: string
                current-amount:
                    type: float

Every account (e.g. `/account/29f585ca-b246-4eea-9d79-a34904f8f19a`)
would have to have this property set, resulting in `properties.yaml`
files like the following:

    name: Personal Savings
    current-amount: 159.27

#### Values

All floating point properties support double precision values.

### Properties of type `text`

#### Definition

Text properties are defined in schemas as follows:

    <name>:
        type: text

They may optionally include a regular expression as a validation
requirement for implementations:

    <name>:
        type: text
        regex: <regular expression>

#### Usage

Assume we were to define a Consonant schema for a kanban system that
includes lanes with a title, an optional description and a CSS color.
The schema for this might look as follows:

    uuid: org.yourproject.kanban.schema.1
    classes:
        lane:
            properties:
                title:
                    type: text
                description:
                    type: text
                color:
                    type: text
                    regex: ^#([0-9abcdefABCDEF]{2}){3}$

Lanes in the store would now have `properties.yaml` files like the
following:

    title: Doing
    description: |
        Tasks that are currently being worked on
        by a member of the project.
    color: #a7d239

#### Values

Text properties can store arbitrary text including whitespace that is
preserved by the store. If a `regex` validation rule is defined, the
value of the text property must in addition satisfy the given regular
expression.

### Properties of type `list`

#### Definition

List properties are defined in schemas as follows:

    <name>:
        type: list
        elements:
            <type definition for elements>

One example would be a list of lists of strings:

    <name>:
        type: list
        elements:
            type: list
            elements:
                type: string

Lists are required to always contain at least one element. The
`optional` flag can be used to define list properties that may be empty
(by not being set at at all).

#### Usage

Assume we were to define a Consonant schema for a kanban system with
cards that optionally have arbitrary strings attached as tags. The
resulting schema might then look like this:

    uuid: org.yourproject.kanban.schema.1
    classes:
        card:
            properties:
                title: string
                tags:
                    type: list
                    elements:
                        type: string
                    optional: true

A card could now have the following `properties.yaml` file including
a list of tags:

    title: Fix bug #5302
    tags:
        - bug
        - priority1

#### Values

If present in `properties.yaml` files, lists must be non-empty. Empty
list properties are realised through the `optional` flag. The allowed
values of list elements depend entirely on the element data type
specified.

### Properties of type `reference`

#### Definition

Reference properties are used to describe references from one object
to another. References may be internal (within the same store) or
external (to objects in a different store). References may also include
a particular target tree or commit (again, in the same or a different
store). Another feature of object references in Consonant is that they
can be unidirectional or bidirectional.

Internal reference properties are defined as follows:

    <name>:
        type: reference
        class: <target class name>

Reference properties for linking to objects in another store are
defined by adding a schema UUID to the property definition:

    <name>:
        type: reference
        class: <target class name>
        schema: <schema UUID>

Note that the above only specifies the schema, allowing Consonant
implementations to locate the class definition of referenced objects
from the schema the UUID is resolved to. The schema does not specify
in which store(s) the referenced external objects are held. This
is purely encoded in the actual property values and may vary from
store to store.

The above definitions define one-way/unidirectional object references.
The `bidirectional` hint may be used to define bidirectional
references. The value of `bidirectional` is the name of a property
of the referenced objects that is expected to hold a reference in
the other direction. Note that the property named by the `bidirectional`
hint may be a list, allowing not just one-to-one bidirectional
references but also one-to-many or many-to-many relationships to be
defined:

    <name>:
        type: reference
        class: <target class name>
        bidirectional: <property name of the target class>

Note: Bidirectional reference properties are only supported for
*internal* references, not for references to objects in another store.

#### Usage

Assume that we were to define a schema for a kanban system with lanes
and cards, where lanes and cards have a one-to-many relationship and
cards may optionally refer to external issue objects in an issue
tracker. The kanban schema for this could include the following:

    uuid: org.yourproject.kanban.schema.1
    classes:
        lane:
            properties:
                title: text
                cards:
                    type: list
                    elements:
                        type: reference
                        class: card
                        bidirectional: lane
        card:
            properties:
                title: text
                lane:
                    type: reference
                    class: lane
                    bidirectional: cards
                issue:
                    type: reference
                    class: issue
                    schema: org.yourproject.issues.schema.1
                    optional: true

With this, every lane in the kanban store would have to have a list of
the cards in the lane in the `cards` property. An example could be the
`properties.yaml` file of a lane with the UUID `doing`:

    title: Doing
    cards:
        - uuid: 2a4f3b0a-b828-40f7-aa4b-ce57480ede52
        - uuid: 998229a6-0562-43c8-8122-7c813603ed9f
        - uuid: 6cc4efed-3a0e-47c5-b387-17e2b3c48d6d

Cards on the other hand would have to have a reference back to the
lane they are in via the `lane` property` and could additional store
a reference to an external issue:

    title: Fix bug #5942
    lane: doing
    issue:
        service: issues
        uuid: ab63d142-0af1-45a8-b813-8dd7e39ffd6e

where `issues` is a alias for the issue tracker service defined in
`consonant.yaml` and `ab63d142-0af1-45a8-b813-8dd7e39ffd6e` is the
UUID of an issue in this issue tracker.

#### Values

The format and allowed content of references depends on whether they
are internal or external. Internal references are specified as a
a dictionary:

- `uuid`: the target object's UUID,
- `ref`: an optional Git ref, tree, commit or tag of the Consonant
  store.

Similarly, external references are specified via a dictionary with
the following keys:

* `uuid`: the UUID of the referenced object,
* `service`: a service alias resolved via the `consonant.yaml` file of
  the store,
* `ref`: an optional Git ref, tree, commit or tag of the target
  Consonant store.

# Consonant services / data interface

Through the data model described in the previous chapter, Consonant
stores already provide an interface to the data that applications can
use to access, query and modify objects. To support the rapid
development of web services on top of Consonant stores, however, a
standard web API is desirable.

This chapter defines a standard web API for accessing Consonant stores.
Implementations of this web API are called *Consonant services*.

## Web API characteristics

This section covers some of the main characteristics of the web API,
along with explanations of why they are so important.

### API versioning

Interfaces almost inevitably change over time. The
changes made may or may not compatible. This is why it is important
to establish a understanding of the interface version being used in
the communication between server and client. Versioning interfaces
has proven to be good practice for protocols (e.g. HTTP 1.0 vs. 1.1),
D-Bus service interfaces (e.g.  `org.freedesktop.systemd1.Manager`)
and web APIs (e.g. `http://api.twitter.com/1/` vs.
`http://api.twitter.com/1.1/`).

The Consonant web API is versioned by being encapsulated in the
following URL prefix:

    http://url.of.service/consonant/api/<version>/

The first version of the API resides under

    http://url.of.service/consonant/api/1.0/

### REST-like design

REST has become a standard approach to designing web APIs. Consonant
follows the same principles, including

* a client-server model,
* stateless communication (services store no client state),
* cacheable responses,
* support for transparent addition of layers on top of the underlying
  store without affecting the web API,
* a uniform interface to the data that all Consonant services
  implement.

Note that the above does not apply to the streaming API defined in
the *Streaming API* section, which involves client state being stored
on the server side as well as making it impossible to cache most of the
communication.

### Support for both YAML and JSON

Since the underlying data model uses YAML to represent schemas, store
configurations as well as objects and their properties it seems natural
to formulate the web API in terms of exchanging YAML data. However,
many clients will find it easier to generate and process JSON,
especially those written in JavaScript.

To compensate for this problem, all methods of the Consonant web API
accept or return both YAML and JSON.

Request data has to be marked appropriately by setting either
`Content-Type: application/x-yaml` or
`Content-Type: application/json` in the HTTP request header.

The desired response format has to be specified by setting the `Accept`
header to either `Accept: application/x-yaml` or
`Accept: application/json` when sending an HTTP request that will
result in a response with data.

#### YAML versus JSON example

The following example shows the same `GET` request being made with
`Accept: application/x-yaml` and `Accept: application/json`. In the
rest of this chapter, all examples will use YAML but you can safely
assume that JSON can be used in exactly the same way.

First, the request using YAML:

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/schema                               |
|                      |     Accept: application/x-yaml                                  |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     Content-Type: application/x-yaml                            |
|                      |                                                                 |
|                      |     uuid: org.yourproject.kanban.schema.1                       |
|                      |     classes:                                                    |
|                      |       lane:                                                     |
|                      |         properties:                                             |
|                      |           title:                                                |
|                      |             type: text                                          |
|                      |           cards:                                                |
|                      |             type: list                                          |
|                      |             elements:                                           |
|                      |               type: reference                                   |
|                      |               class: card                                       |
|                      |               bidirectional: lane                               |
|                      |       card:                                                     |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

Second, the same request using JSON:

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/schema                               |
|                      |     Accept: application/json                                    |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     Content-Type: application/json                              |
|                      |                                                                 |
|                      |     {                                                           |
|                      |       "uuid": "org.yourproject.kanban.schema.1",                |
|                      |       "classes": {                                              |
|                      |         "lane": {                                               |
|                      |           "properties": {                                       |
|                      |             "title": {                                          |
|                      |               "type": "text"                                    |
|                      |             },                                                  |
|                      |             "cards": {                                          |
|                      |               "type": "list"                                    |
|                      |               "elements": {                                     |
|                      |                 "type": "reference"                             |
|                      |                 "class": "card"                                 |
|                      |                 "bidirectional": "lane"                         |
|                      |               }                                                 |
|                      |             }                                                   |
|                      |           }                                                     |
|                      |         },                                                      |
|                      |         "card": {                                               |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

## Basic API

The basic Consonant web API includes a set of `GET` methods to retrieve
the schema used by the underlying store, classes, objects, properties,
attachments and Git refs such as branches and tags. It also includes a
`POST` method to modify objects in the store in the form of
transactions.

### `GET /schema`

Returns the schema used by the underlying store managed by the Consonant
service. Use the HTTP `Accept` header to specify whether the schema
should be returned as YAML or JSON:

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/schema                               |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     uuid: org.yourproject.kanban.schema.1                       |
|                      |     classes:                                                    |
|                      |       lane:                                                     |
|                      |         properties:                                             |
|                      |           title:                                                |
|                      |             type: text                                          |
|                      |           cards:                                                |
|                      |             type: list                                          |
|                      |             elements:                                           |
|                      |               type: reference                                   |
|                      |               class: card                                       |
|                      |               bidirectional: lane                               |
|                      |       card:                                                     |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

### `GET /classes`

Returns a YAML or JSON dictionary mapping the names of all classes
available in the store to some meta data, including:

* the number of objects of the class,
* ...?

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes                              |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     lane:                                                       |
|                      |       objects:                                                  |
|                      |         total:  7                                               |
|                      |         active: 5                                               |
|                      |         hidden: 2                                               |
|                      |     card:                                                       |
|                      |       objects:                                                  |
|                      |         total:  233                                             |
|                      |         active: 217                                             |
|                      |         hidden: 16                                              |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class`

Like `GET /classes` but fetches the meta data for a single class only.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/lane                         |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     lane:                                                       |
|                      |       objects:                                                  |
|                      |         total:  7                                               |
|                      |         active: 5                                               |
|                      |         hidden: 2                                               |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects`

Fetches all objects of a given class, including their properties and
attachment names. The response does not include any attachment meta
data or content. Object references are not resolved recursively; this
is the responsibility of the client.

The objects of the class are returned as a list of dictionaries.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/card/objects                 |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     - uuid: ccb920a2-810a-4264-b022-d92f36f849bf                |
|                      |       class: card                                               |
|                      |       hidden: false                                             |
|                      |       properties:                                               |
|                      |         title: Fix bug #5932                                    |
|                      |         comments:                                               |
|                      |           - uuid: e96dcdf9-fd5f-4e66-af73-58db9ee15701          |
|                      |           - uuid: b7dbfd80-8afd-44a7-a636-f69c5a9fe517          |
|                      |       attachments:                                              |
|                      |         - screenshot.png                                        |
|                      |     - uuid: 445bf6d4-6dd2-4817-a657-27329b5fbff8                |
|                      |       class: card                                               |
|                      |       hidden: false                                             |
|                      |       properties:                                               |
|                      |         title: Implement feature XYZ                            |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid`

Takes a class name and object UUID and returns the properties and
attachment names for the corresponding object. Returns a 404 if the
class does not exist or if the object UUID does not refer to an object
of the given class.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/lane/objects/...             |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca                  |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     class: lane                                                 |
|                      |     hidden: false                                               |
|                      |     properties:                                                 |
|                      |       title: Backlog                                            |
|                      |       cards:                                                    |
|                      |         - uuid: c545a172-6960-411c-bd06-e4cd9efb2a29            |
|                      |         - uuid: f985009e-e52b-4f4c-a6bd-34d27462e000            |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/properties`

Takes a class name and object UUID and returns the properties for the
corresponding object. Returns a 404 if the class does not exist or if
the object UUID does not refer to an object of the given class.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/lane/objects/...             |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca/...              |
|                      |           properties                                            |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     title: Backlog                                              |
|                      |     cards:                                                      |
|                      |       - uuid: c545a172-6960-411c-bd06-e4cd9efb2a29              |
|                      |       - uuid: f985009e-e52b-4f4c-a6bd-34d27462e000              |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/properties/:property`

Takes a class name, an object UUID and a property name and returns the
value of the corresponding object property. Returns a 404 if the class
does not exist, if the object UUID does not refer to an object of the
given class or if a property with the given name does not exist in the
class.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/lane/objects/...             |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca/...              |
|                      |           properties/title                                      |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     Backlog                                                     |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/attachments`

Takes a class name and an object UUID and returns a dictionary mapping
the names of all attachments of the corresponding objec to their meta
data.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/card/objects/...             |
|                      |           ccb920a2-810a-4264-b022-d92f36f849bf/...              |
|                      |           attachments                                           |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     screenshot.png:                                             |
|                      |       content-type: image/png                                   |
|                      |       properties:                                               |
|                      |         description: Screenshot of the bug.                     |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/attachments/:name`

Takes a class name, an object UUID and an attachment name and returns
the meta data for the attachment. Returns a 404 if the class does not
exist, if the object UUID does not refer to an object of the given
class or if no attachment with the given name exists for the object.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/card/objects/...             |
|                      |           ccb920a2-810a-4264-b022-d92f36f849bf/...              |
|                      |           attachments/screenshot.png                            |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     content-type: image/png                                     |
|                      |     properties:                                                 |
|                      |       description: Screenshot of the bug.                       |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/attachments/:name/data`

Takes a class name, an object UUID and an attachment name and returns
the data of the attachment. The response has the `Content-Type` header
set to the `content-type` of the attachment meta data. Returns a 404
if the class does not exist, if the object UUID does not refer to an
object of the given class or if no attachment with the given name
exists for the object.

### `GET /objects`

Returns all objects defined in the store, including their properties and
attachment names. The response does not include any attachment meta data
or content. Object references are not resolved recursively; this is the
responsibility of the client.

The result is a dictionary that maps class names to lists of objects.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/objects                              |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     lane:                                                       |
|                      |       - uuid: b5decbb8-54b6-49a7-923b-7c3e04dfadca              |
|                      |         class: lane                                             |
|                      |         hidden: false                                           |
|                      |         properties:                                             |
|                      |           title: Backlog                                        |
|                      |           cards:                                                |
|                      |             - uuid: c545a172-6960-411c-bd06-e4cd9efb2a29        |
|                      |             - uuid: f985009e-e52b-4f4c-a6bd-34d27462e000        |
|                      |         attachments:                                            |
|                      |           - screenshot.png                                      |
|                      |       - uuid: dcb7a3e2-0da2-4ca9-befe-122ddd2b9ac2              |
|                      |         class: lane                                             |
|                      |         ...                                                     |
|                      |     cards:                                                      |
|                      |       - uuid: d75be68f-412f-4a5a-b59b-2c4e9cb94b2c              |
|                      |         class: card                                             |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

### `GET /objects/:uuid`

Takes an object UUID and returns the properties and attachment names
for the corresponding object. Returns a 404 if the object UUID does not
refer to an existing object in the store.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/objects/...                          |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca                  |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     class: lane                                                 |
|                      |     hidden: false                                               |
|                      |     properties:                                                 |
|                      |       title: Backlog                                            |
|                      |       cards:                                                    |
|                      |         - uuid: c545a172-6960-411c-bd06-e4cd9efb2a29            |
|                      |         - uuid: f985009e-e52b-4f4c-a6bd-34d27462e000            |
|                      |     attachments:                                                |
|                      |       - screenshot.png                                          |
+----------------------+-----------------------------------------------------------------+

### `GET /objects/:uuid/class`

Takes an object UUID and returns the name of the object class. Returns
a 404 if the object UUID does not refer to an existing object in the
store.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/objects/...                          |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca/class            |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     lane                                                        |
+----------------------+-----------------------------------------------------------------+

### `GET /objects/:uuid/properties`

Like `GET /classes/:class/objects/:uuid/properties` except that it
requires no class name and only takes an object UUID.

### `GET /objects/:uuid/properties/:property`

Like `GET /classes/:class/objects/:uuid/properties/:property` except
that it requires no class name and only takes an object UUID and
property name.

### `GET /objects/:uuid/attachments`

Like `GET /classes/:class/objects/:uuid/attachments` except that it
requires no class name and only takes an object UUID.

### `GET /objects/:uuid/attachments/:name`

Like `GET /classes/:class/objects/:uuid/attachments/:name` except that
it requires no class name and only takes an object UUID and attachment
name.

### `GET /objects/:uuid/attachments/:name/data`

Like `GET /classes/:class/objects/:uuid/attachments/:name` except that
it requires no class name and only takes an object UUID and attachment
name.

### `GET /refs`

Returns all releveant Git refs of the underlying store. This usually
includes branches and tags. The Git refs are returned as a dictionary
mapping ref names (e.g. `refs/heads/username/branchname`) to another
dictionary per ref, including the following keys:

* `type`: either `branch` or `tag`,
* `url-aliases`: a list of URL aliases (e.g. `username:branchname`) for
  the ref that can be passed to Consonant web URLs safely (see the
  other `GET /refs/...` methods),
* `head`: most recent commit in the branch (if the ref is a branch) or
  the commit that was tagged (if the ref is a tag); this is again a
  dictionary providing not just the commit SHA1 but also authorship
  information:
    - `sha1`: the commit SHA1 (which can be passed to other
      `GET /refs/...` methods safely),
    - `author`: the author of the commit,
    - `author-date`: the author date in raw Git date format (%s %z),
    - `committer`: the committer,
    - `committer-date`: the commit date in raw Git date format (%s %z),
    - `subject`: the commit subject,
    - `parents`: a list of parent commit SHA1s.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/refs                                 |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     HEAD:                                                       |
|                      |       type: branch                                              |
|                      |       url-aliases:                                              |
|                      |         - HEAD                                                  |
|                      |       head:                                                     |
|                      |         sha1: 5c37acbad6f545445eaf07983b40e11d4d7354dc          |
|                      |         author: Jeff Arnold <jeff@yourproject.org>              |
|                      |         author-date: 1374684008 +0100                           |
|                      |         committer: Jeff Arnold <jeff@yourproject.org>           |
|                      |         committer-date: 1374782771 +0100                        |
|                      |         subject: Archive a couple of kanban cards               |
|                      |         parents:                                                |
|                      |           - ff49cf94860caea73fd50c797735eeb10a3b1ab5            |
|                      |           - 9080579c0387268fe41b4474b25b01baa2ef9f7c            |
|                      |     refs/heads/master:                                          |
|                      |       type: branch                                              |
|                      |       url-aliases:                                              |
|                      |         - master                                                |
|                      |         - refs:heads:master                                     |
|                      |       head:                                                     |
|                      |         sha1: 5c37acbad6f545445eaf07983b40e11d4d7354dc          |
|                      |         author: Jeff Arnold <jeff@yourproject.org>              |
|                      |         author-date: 1374684008 +0100                           |
|                      |         committer: Jeff Arnold <jeff@yourproject.org>           |
|                      |         committer-date: 1374782771 +0100                        |
|                      |         subject: Archive a couple of kanban cards               |
|                      |         parents:                                                |
|                      |           - ff49cf94860caea73fd50c797735eeb10a3b1ab5            |
|                      |           - 9080579c0387268fe41b4474b25b01baa2ef9f7c            |
|                      |     refs/tags/work-package-1:                                   |
|                      |       type: tag                                                 |
|                      |       url-aliases:                                              |
|                      |         - work-package-1                                        |
|                      |         - refs:tags:work-package-1                              |
|                      |       head:                                                     |
|                      |         sha1: 1f64f272ee61f65d3f539166f6526b7e2e6419e9          |
|                      |         author: Michael Hobson <micheal@yourproject.org>        |
|                      |         author-date: 1375449899 +0100                           |
|                      |         committer: Jeff Arnold <jeff@yourproject.org>           |
|                      |         committer-date: 1375464272 +0100                        |
|                      |         subject: Define milestones for work package 1           |
|                      |         parents:                                                |
|                      |           - ff49cf94860caea73fd50c797735eeb10a3b1ab5            |
+----------------------+-----------------------------------------------------------------+

### `GET /refs/:ref`

Like `GET /refs` except that it takes the name/SHA1 of a Git ref and
returns information about that ref only.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/refs/master                          |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |       url-aliases:                                              |
|                      |         - master                                                |
|                      |         - refs:heads:master                                     |
|                      |       head:                                                     |
|                      |         sha1: 5c37acbad6f545445eaf07983b40e11d4d7354dc          |
|                      |         author: Jeff Arnold <jeff@yourproject.org>              |
|                      |         author-date: 1374684008 +0100                           |
|                      |         committer: Jeff Arnold <jeff@yourproject.org>           |
|                      |         committer-date: 1374782771 +0100                        |
|                      |         subject: Archive a couple of kanban cards               |
|                      |         parents:                                                |
|                      |           - ff49cf94860caea73fd50c797735eeb10a3b1ab5            |
|                      |           - 9080579c0387268fe41b4474b25b01baa2ef9f7c            |
+----------------------+-----------------------------------------------------------------+

### `GET /refs/:ref/*`

The base URL `/refs/:ref/` replicates the functionality in `GET /` but
works against a specific Git ref instead of `HEAD`.

This means the methods

* `GET /refs/:ref/classes`
* `GET /refs/:ref/classes/:class`
* `GET /refs/:ref/classes/:class/objects`
* `GET /refs/:ref/classes/:class/objects/:uuid`
* `GET /refs/:ref/classes/:class/objects/:uuid/properties`
* `GET /refs/:ref/classes/:class/objects/:uuid/properties/:property`
* `GET /refs/:ref/classes/:class/objects/:uuid/attachments`
* `GET /refs/:ref/classes/:class/objects/:uuid/attachments/:name`
* `GET /refs/:ref/classes/:class/objects/:uuid/attachments/:name/data`
* `GET /refs/:ref/objects`
* `GET /refs/:ref/objects/:uuid`
* `GET /refs/:ref/objects/:uuid/class`
* `GET /refs/:ref/objects/:uuid/properties`
* `GET /refs/:ref/objects/:uuid/properties/:property`
* `GET /refs/:ref/objects/:uuid/attachments`
* `GET /refs/:ref/objects/:uuid/attachments/:name`
* `GET /refs/:ref/objects/:uuid/attachments/:name/data`

all provide the same interface as

* `GET /classes`
* `GET /classes/:class`
* `GET /classes/:class/objects`
* etc.

except that they retrieve the store data from the Git ref `:ref` instead
of the default `HEAD`.

## Transaction API

Transactions can be thought of as a semantic interpretation of commits
to the underlying Consonant repository. Where commits create, modify
and delete files in the repository, transactions create, modify and
delete objects and their properties.

The transaction API allows to submit transactions to a Consonant
service in order to apply changes to its objects via
`POST /transactions`. It also provides a way to obtain transactions
previously made to the store via the SHA1 of their corresponding
commits through `GET /transactions/:sha1`.

Meta data for a commit, including authorship information, parent
commits and a less detailed overview of the changes made by a commit
can be obtained via a separate method `GET /commits/:sha1`.

### `POST /transactions`

Takes `multipart/mixed` data representing one or more transactions, each
including one or more actions, including

* object creation and deletion,
* object manipulation, and
* object attachment creation, deletion and modification.

The multipart data is structured as a mix of YAML/JSON actions and parts
with arbitrary content types for attachment data. Each transaction
begins with a `begin` action and ends with a `commit` action.

It is mandatory for Consonant implementations to verify that
transactions result in valid stores, i.e., stores that validate
successfully against their schema. This also means that any change to
a bidirectional reference in a transaction always involves removing
the old back-reference as well as the new back-reference.

#### Begin of transaction

Each transaction starts with a `begin` action. It contains the SHA1 of
the Git commit to base the changes on:

    Content-Type: multipart/mixed; boundary=NEXTPLEASE

    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: begin
    source: <commit SHA1>

#### End of transaction

Each transaction ends with a `commit` action. It has to include the
following information:

* `target`: name of the Git ref to apply the transaction to (e.g.
  `refs/heads/master`),
* `author`: name and email address of the person who is making
  the changes or has made them originally (format:
  `FIRSTNAME LASTNAME <EMAIL>`),
* `author-date`: timestamp of the original change (format: `%s %z`),
* `committer`: name and email address of the person who is submitting
  the changes (format: `FIRSTNAME LASTNAME <EMAIL>`),
* `committer-date`: timestamp of the transaction submission,
* `message`: commit message in the following format:

        Subject line briefly describing the changes, max 72 characters

        Zero or more paragraphs describing the changes in more detail.
        These paragraphs follow the same max 72 characters per line
        limits.

        This is just another paragraph to demonstrate that it is ok
        to have more than one.

The following example shows an empty transaction with a `begin` and
a `commit` action:

    Content-Type: multipart/mixed; boundary=NEXTPLEASE

    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: begin
    source: f26c77d56a98374ead1aaf7608984ff3746636c1
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: commit
    target: refs/heads/master
    author: Samuel Bartlett <samuel@yourproject.org>
    author-date: 1374687746 +0100
    committer: IRC Code Review Bot <reviewbot@yourproject.org>
    committer-date: 1374782771 +0100
    message: +1 by Samuel to merge request MR3912

#### Object creation

Object creation is performed via `create` actions, each associated
with an identifier that is unique among action identifiers within the
transaction as well as an object class.

The `properties` key holds a dictionary mapping that defines what the
different properties of the object to be created shall be set to.

An example transaction creating a kanban card with a specific title
and description could look as follows:

    Content-Type: multipart/mixed; boundary=NEXTPLEASE

    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: begin
    source: 8606830399b5f46100ee0985154662dabe9d1080
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: create
    id: 1
    class: card
    properties:
      title: This is a new card
      description: |
        A two-line description for this card explaining what the
        task is about and where developers can find additional
        information about related APIs.
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: commit
    target: refs/heads/master
    ...

#### Object deletion

Object deletion is performed via `delete` actions, each associated
with an identifier that is unique among action identifiers within the
transaction as well as an object class.

An example transaction deleting a kanban card with a specific object
UUID could look as follows:

    Content-Type: multipart/mixed; boundary=NEXTPLEASE

    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: begin
    source: 8606830399b5f46100ee0985154662dabe9d1080
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: delete
    id: 1
    uuid: 3c9924d6-e5a6-4b77-8f40-92dbfaf9ff19
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: commit
    target: refs/heads/master
    ...

#### Object manipulation

Object manipulation is performed via `update` actions, each associated
with an identifier that is unique among action identifiers within the
transaction as well as an object class.

The `properties` key holds a dictionary mapping that maps manipulated
properties to the desired new values.

An example transaction manipulating a kanban card by changing its
title and assignee could look as follows:

    Content-Type: multipart/mixed; boundary=NEXTPLEASE

    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: begin
    source: 8606830399b5f46100ee0985154662dabe9d1080
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: update
    id: 1
    class: card
    properties:
      title: New title for the card
      assignees:
          - jeff@yourproject.org
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: commit
    target: refs/heads/master
    ...

#### Attachment creation, deletion and manipulation

Attachments can be created, deleted and updated as part of any
transaction. These actions are, however, different from regular object
actions in that they usually come in the form of two parts:

* The first part describes the type of action, the object UUID, the
  attachment name and, optionally, meta data being changed.
* The second part contains the actual attachment data. This part is
  only valid for `create-attachment` and `update-attachment` actions
  and is optional for `update-attachment` actions if only the
  attachment meta data is being changed.

The first part is a YAML or JSON segment of the form

    Content-Type: application/x-yaml

    action: {create,delete,update}-attachment
    object: <uuid or action ID>

with an optional `metadata` field for `create-attachment` and
`update-attachment` to describe changes to the attachment meta
data (JSON will be transformed to YAML in the store):

    Content-Type: application/x-yaml

    action: <create|update>-attachment
    id: <action ID>
    object: <uuid or action ID>
    metadata:
      - some
      - arbitrary
      - yaml: or json
        meta: data

The second part is the actually attachment data, which comes in the
form of an arbitrary `Content-Type` and data.

An example transaction that adds a patch attachment to an issue in an
issue tracker could look as follows:

    Content-Type: multipart/mixed; boundary=NEXTPLEASE

    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: begin
    source: 8606830399b5f46100ee0985154662dabe9d1080
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: create-attachment
    id: 1
    object: decf91ab-fc9c-4e3c-a838-09d704663a87
    metadata:
      author: nick@xfce.org
      mime-type: text/plain
      comment: |
        This patch makes Thunar use the "utilities-terminal" icon
        name for the default UCA action.
    --NEXTPLEASE
    Content-Type: text/plain

    diff --git a/plugins/thunar-uca/uca.xml.in b/plugins/thunar-uca/uca.xml.in
    --- a/plugins/thunar-uca/uca.xml.in
    +++ b/plugins/thunar-uca/uca.xml.in
    @@ -36,6 +36,6 @@
     <actions>

       <action>
    -    <icon>Terminal</icon>
    +    <icon>utilities-terminal</icon>
         <patterns>*</patterns>
         <_name>Open Terminal Here</_name>
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: commit
    target: refs/heads/master
    ...

#### References to newly created objects

When sending transactions with changes to Consonant services, it is
often necessary to include references to objects that are being created
as part of the transaction and have an unknown object UUID.

Examples are:

* Creating a kanban card with a bidirectional reference to its lane
  requires to also insert a reference to this new card in the lane.
* Moving a kanban card with a bidirectional reference to its lane from
  one lane to another requires the reference to the card to be removed
  from the old lane and a new reference to the card to be inserted in
  its new lane.
* Creating an object along with uploading an attachment for it requires
  a reference from the attachment to the object since, at the point of
  sending the transaction, the object UUID is unknown.

This is what the action IDs of `POST /transaction` are for: in addition
to regular references of the form

    - uuid: <object UUID>

with optional `service` and `ref` values, references may have the form

    - action: <action ID>

to refer to an object being created or manipulated in one of the
create, delete or update actions of the transaction.

An example transaction creating a new kanban lane for reviews and moving
a kanban card from its old lane into the new review lane could look as
follows:

    Content-Type: multipart/mixed; boundary=NEXTPLEASE

    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: begin
    source: 8606830399b5f46100ee0985154662dabe9d1080
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: create
    id: 1
    class: lane
    properties:
      title: Review lane
      cards:
        - 1c562045-0e09-40ca-9f5a-08a697f598ca
    --NEXTPLEASE
    Content-type: application/x-yaml

    action: update
    id: 2
    uuid: 1c562045-0e09-40ca-9f5a-08a697f598ca
    properties:
      lane:
        action: 1
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: update
    id: 3
    uuid: 3caf9294-d72e-4147-9bb2-d21e90782cd4
    properties:
      cards:
        - uuid: d215eefa-8b67-47df-bb0d-134fc4640c23
        - uuid: 04dfaa16-8368-4c30-ab2e-2b08a3800f7b
        - uuid: 27d3d3e0-f8a3-4174-acb0-b05ad84b0746
    --NEXTPLEASE
    Content-Type: application/x-yaml

    action: commit
    target: refs/heads/master
    ...

Note how the above example also updates the old lane in action 3 by
updating its `cards` property to no longer include a reference to
the moved card.

### `GET /transactions/:sha1`

Obtains the transaction information for a given Git commit SHA1.
The result is a list of actions included in the transaction, each
represented as a dictionary with an `action` key and other keys
dependent on the type of the action (see `POST /transactions` for
more information).

The output format of `GET /transactions/:sha1` is similar but different
to the input of `POST /transactions`:

* The format is a single YAML/JSON dictionary and not a multipart/mixed
  document.
* The `target` of the `commit` action is a Git commit SHA1 instead
  of a symbolic ref like `refs/heads/master`.
* The values of binary properties are not included in the result
  but are provided as links.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/transactions/...                     |
|                      |           12f4b1d99ad018d6fac45703ba63de491d320f6a              |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     - action: begin                                             |
|                      |       source: c1dd82cba74fa4b8d14b66f7275d0c5a1169a7ad          |
|                      |     - action: create                                            |
|                      |       id: 1                                                     |
|                      |       class: lane                                               |
|                      |       properties:                                               |
|                      |         title: Review lane                                      |
|                      |         cards:                                                  |
|                      |           - 1c562045-0e09-40ca-9f5a-08a697f598ca                |
|                      |     - action: update                                            |
|                      |       id: 2                                                     |
|                      |       uuid: 1c562045-0e09-40ca-9f5a-08a697f598ca                |
|                      |       properties:                                               |
|                      |         lane:                                                   |
|                      |           action: 1                                             |
|                      |     - action: update                                            |
|                      |       id: 3                                                     |
|                      |       uuid: 3caf9294-d72e-4147-9bb2-d21e90782cd4                |
|                      |       properties:                                               |
|                      |         cards:                                                  |
|                      |           - uuid: d215eefa-8b67-47df-bb0d-134fc4640c23          |
|                      |           - uuid: 04dfaa16-8368-4c30-ab2e-2b08a3800f7b          |
|                      |           - uuid: 27d3d3e0-f8a3-4174-acb0-b05ad84b0746          |
|                      |     - action: commit                                            |
|                      |       target: 6fcf141e93449fb932e2e1ba0d18b9b817ea1694          |
|                      |       ...                                                       |
+----------------------+-----------------------------------------------------------------+

### `GET /transactions/:from/:to`

Takes two Git commit refs or SHA1s and returns the contents of a
transaction that would update the store from the state in ref or commit
`:from` to the state in ref or commit `:to`.

Possible use cases for this include:

1. Polling for all changes to a ref (e.g. `refs/heads/master`) since the
   last known transaction (e.g.
   `805cf1a2cf23ac2f4b1de23ee9b5eec98c815953`):

        GET /consonant/api/1.0/transactions/
              805cf1a2cf23ac2f4b1de23ee9b5eec98c815953/master
2. Obtain the reverse transaction in order to undo a change.
3. Obtain the transaction equivalent to merging two branches.

The output format of `GET /transactions/:from/:to` is equivalent to
that of `GET /transactions/:sha1` except that, since the transaction
may not actually exist in the store as a commit, some fields of the
`commit` action may not be set. This includes the fields `target`,
`author`, `author-date`, `committer`, `committer-date` and `message`.

### `GET /commits/:sha1`

Takes a Git commit SHA1 and returns information about the commit,
including the parent commits (left parent first, then optionally right
parent in case of merge commits).

This method does not fully expand changes to objects into actions like
`GET /transactions/:sha1` does. Instead, it only lists which objects
have been added, modified and deleted by listing their UUIDs.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/commits/..                           |
|                      |           1425674028f4936dacb82e925ad1d7daa66fe810              |
+----------------------+-----------------------------------------------------------------+
|                      |     sha1: 1425674028f4936dacb82e925ad1d7daa66fe810              |
|                      |     parents:                                                    |
|                      |       - 82b003ed458f7d689e190ac31a1fb6834fa73541                |
|                      |       - 2d5c01132d0213e1135bb893027ae2676c900aa0                |
|                      |     author: Aidan Wilkins <aidan@yourproject.org>               |
|                      |     author-date: 1376405234 +0100                               |
|                      |     committer: Aidan Wilkins <aidan@yourproject.org>            |
|                      |     committer-date: 1376405234 +0100                            |
|                      |     message: Update project kanban after meeting                |
|                      |     objects:                                                    |
|                      |       added:                                                    |
|                      |         - 0a29c340-fa82-419d-9041-7042282300c1                  |
|                      |         - e609775d-fd34-49fb-bc6d-f619de6ac17e                  |
|                      |         - c5b79eb8-fbce-4d3a-859f-fcc7f0499b1a                  |
|                      |       modified:                                                 |
|                      |         - 29c483e8-ae3c-4aec-bd1a-42070a532fd8                  |
|                      |       deleted:                                                  |
|                      |         - 741581e1-ef85-42db-ad69-2ec398a2a6aa                  |
|                      |         - 9c8c11c5-6780-48a0-b997-d85d4b0290af                  |
+----------------------+-----------------------------------------------------------------+

## Query API

While for some applications simple object access via the basic API may
be sufficient, more complex applications will almost always require
more advanced ways of filtering and fetching objects from the store.

The query API provides a way to formulate advanced queries by
representing each Consonant store as a directed, potentially cyclic
graph. This graph is then processed with a simple graph query language.

This section describes the query graph, the query language, the query
output format and the actual query web API.

### Query graph

The graph of a Consonant store consists of three types of nodes, *commit
nodes*, *class nodes* and *object nodes*, all of which have attributes
pointing to the underlying commits, classes and objects as well as
other nodes. Instead of having explicit edge elements in the graph,
connections between nodes are expressed via attributes that reference
other nodes.

*Commit nodes* each represent a commit in the store. There are as many
commit nodes as there are commits in the store. Each commit node has
the following attributes:

* `path`: a unique node path (see the *Node paths* section);
* `commit`: the commit represented by the commit node;
* `parents`: a list of references to the commit nodes representing
  the parent commits of the commit represented by the node itself,
  with the left parent node reference, if present, coming first;
  `parents` may be empty if the commit has no parents;
* `classes`: a set of references to all class nodes representing
  classes in the commit represented by the commit node.
* `objects`: a set of references to all object nodes representing
  objects in the commit represented by the commit node.

*Class nodes* each represent an object class at a specific commit of
a store. There is one class node for each class directory in each
commit of the store. Each class node has the following attributes:

* `path`: a unique node path (see the *Node paths section);
* `commit`: a reference to the commit node of the commit the class
  directory was loaded from;
* `objects`: a set of references to all objects in the class at the
  commit the class directory was loaded from.

*Object nodes* each represent an object at a specific commit of a
store. There is one object node for each object in each commit of
the store. While the underlying objects may be present in various
commits, object nodes only exist once in the graph. Each object
node has the following attributes:

* `path`: a unique node path (see the *Node paths* section);
* `object`: the object represented by the object node;
* `commit`: a reference to the commit node of the commit the object
  was loaded from;
* another attributes `X` for each reference or reference list property
  `X` of the represented object, with references to the nodes
  corresponding to the objects referenced to via `X`.

Where the original objects and the references between them can be
thought of as a regular directed graph or *data graph*, the
*query graph* can be thought of as adding another layer on top with
references back down into the data graph via the `object` attribute
of object nodes.

Note: query graphs are only created per-store. In theory, the graphs
of any related set of stores could be combined into a single graph
by connecting object nodes according to their cross-store
references. The responsibility to establish a single graph for
connected stores is, however, left to clients in order to keep the
server-side handling of queries simple.

### Query language

The query language is a simple language designed specifically for
traversing the query graph and extracting subsets of its nodes.  Like
everything else in Consonant, queries can be expressed either as YAML
or as JSON. The query language itself specifies:

* a combination of valid YAML/JSON expressions,
* a node path syntax for uniquely addressing nodes and node sets, and
* a set of boolean filters to operate on node attributes and object
  properties, for terminating traversals and filtering results.

Queries consists of a name and either a *set filter* or a
*arbitrary-depth graph traversal*, the query body. Queries are
defined as a YAML/JSON key/value pair, where the name is the key
and the query body is the value:

    <query name>:
        <query body>

#### Node paths

A key concept in both, set filters and graph traversals, are node
paths. They provide a way of uniquely addressing nodes and sets of
nodes in the graph.

Node paths are defined as follows:

* `[<store uuid>]`: refers to all commit nodes in the store with the
  given UUID;
* `[<store uuid>].[<sha1>]`: refers to the commit node for the commit
  with the given SHA1 in the store with the given UUID;
* `[<store uuid>].[<sha1>]`.classes: refers to all class nodes for the
  commit node for the commit with the given SHA1 in the store with
  the given UUID;
* `[<store uuid>].[<sha1>].classes.<name>`: refers to the class node
  for the given class name and commit node for the commit with the
  given SHA1 in the store with the given UUID;
* `[<store uuid>].[<sha1>].objects`: refers to all object nodes for the
  commit node for the commit with the given SHA1 in the store with the
  given UUID;
* `[<store uuid>].[<sha1>].objects.<uuid>`: refers to the object node
  with the given UUID of the commit node for the given ref/sha1 in
  the store with the given store UUID.

In addition, there are ambiguous node paths for refering to commits,
class and objects pointed to by a Git ref:

* `[<store uuid>].[<ref>]`: refers to all object nodes of the commit
  node of the given Git ref in the store with the given UUID;
* `[<store uuid>].[<ref>]`.classes: refers to all class nodes of the
  commit node for the given Git ref in the store with the given UUID;
* `[<store uuid>].[<sha1>].classes.<name>`: refers to the class node
  for the given class name and commit node for the commit with the
  given SHA1 in the store with the given UUID;
* `[<store uuid>].[<sha1>].objects`: refers to all object nodes for
  the commit node for the given Git ref in the store with the given
  store UUID.
* `[<store uuid>].[<sha1>].objects.<uuid>`: refers to the object node
  with the given UUID for the commit node for the given Git ref in
  the store with the given store UUID.

#### Query root

Every query has a root. This is always a set of nodes or a single node
(e.g. a commit node, class node or object node) addressed by a query
root node path that is either explicitly provided by the entity
submitting the query or implicitly derived from things like the
URL or method the query is submitted to.

#### Fixed-depth graph traversal

Starting from either a node path or a specific node, fixed-depth graph
traversals provide a way to recursively follow references to other
nodes up to a limited depth. This is a key feature to make filtering
and traversal termination conditions in set filters and arbitrary-depth
graph traversals powerful enough to be useful.

The syntax for fix-depth graph traversals follows the same structure
as node paths: segments separated by dots. Any fixed-depth graph
traversal expression is composed of two parts:

1. a node path or variable name (see *Set filters* and
   *Arbitrary-depth graph traversals* for more information about
   variables),
2. an optional, mixed sequence of node attribute names and numeric
   indices, separated by dots.

Examples:

* `root.commit.parents.0`: starting from the query root node (`root`),
  follows the reference to its commit node, then the parent commit
  nodes of that commit and returns the first parent commit node;
* `foo.cards.assignees`: starting from a node represented by a variable
  named `foo`, follows the node references in its `cards` attribute,
  then returns the nodes referenced by the `assignees` attribute of all
  the `cards` nodes;
* `[HEAD].classes.lane`: a node path only traversal selecting the class
  node for `lane` class relative to the commit node for the commit
  pointed to by the Git ref `HEAD`.

#### Set filters

A set filter takes a list of input node sets and returns a set of
nodes based on the union of the input sets. The resulting nodes
stem either directly from the input sets or from a uniform fixed
depth traversal of the graph starting at the nodes from the input
sets.

Set filters are defined as dictionaries with the following fields:

* `yield`: a fixed-depth graph traversal specifying a node or a set
  of nodes to put into the result,
* `for`: a variable name,
* `in`: input sets defined via a mixed list of fixed-depth graph
  traversals and names of other named queries,
* `if` (optional): a list of boolean filters to filter out nodes
  assigned to the variable defined in `for` before they are passed to
  `yield` (see *Filters* for more information about filters).

**Example:** Obtain a set of all object nodes for objects of the
class `lane` that have a non-empty set of cards:

    non-empty-lanes:
      yield: lane
      for: lane
      in:
        - [HEAD].classes.lane.objects
      if:
        - filter: is-set
          attribute: lane.cards

**Example:** Obtain a set of all object nodes that represent cards in
the lane with the title "Backlog". The input set here is the result of
the previous example query (`non-empty-lanes`):

    backlog-cards:
      yield: lane.cards
      for: lane
      in:
        - non-empty-lanes
      if:
        - filter: equals
          property: lane.title
          value: Backlog

#### Arbitrary-depth graph traversals

An arbitrary-depth graph traversal takes a single node and repeatedly
applies a fixed-depth graph traversal until a condition terminates the
traversal. The final result is determined via a fixed-depth traversal
starting from each node that is reached in the recursive traversal,
minus those nodes filtered out using a set of filters.

Arbitrary-depth graph traversals are defined as dictionaries with the
following fields:

* `yield`: a fixed-depth graph traversal specifying a node or a set of
  nodes to put into the result,
* `for`: a variable name,
* `from`: a fixed-depth graph traversal specifying the root of the
  arbitrary-depth graph traversal,
* `via`: a fixed-depth graph traversal specifying the recursion
  traversal,
* `until`: a list of boolean filters that terminate the traversal if
  they are all true at the same time,
* `if` (optional): a list of boolean filters to filter out nodes
  assigned to the variable defined in `for` before they are passed
  to `yield` (see *Filters* for more information about filters).

**Example:** Starting from the Git ref `HEAD`, obtain all commit nodes
for commits since the object with the UUID
`f175f170-1d84-4123-93ba-8e3578697734` was created:

    history:
      yield: commit
      for: commit
      from: [HEAD]
      via: commit.parents.0
      until:
        - filter: contains
          attribute: commit.objects
          nodes:
            - [HEAD].objects.f175f170-1d84-4123-93ba-8e3578697734
          inverted: true

**Example:** Starting from the Git ref `HEAD`, obtain all commit nodes
for commits that changed the object with the UUID
`f175f170-1d84-4123-93ba-8e3578697734` since that object was created:

    history:
      yield: commit
      for: commit
      from: [HEAD]
      via: commit.parents.0
      until:
        - filter: contains
          attribute: commit.objects
          nodes:
            - [HEAD].objects.f175f170-1d84-4123-93ba-8e3578697734
      if:
        - filter: contains
          property: commit.changes
          value:
            uuid: f175f170-1d84-4123-93ba-8e3578697734

#### Boolean filters

TODO

### `POST /query`

TODO

### `POST /classes/:class/query`

TODO

### `POST /classes/:class/objects/:uuid/query`

TODO

### `POST /objects/:uuid/query`

TODO

### `POST /refs/:ref/query`

TODO

### `POST /refs/:ref/classes/:class/query`

TODO

### `POST /refs/:ref/classes/:class/objects/:uuid/query`

TODO

### `POST /refs/:ref/objects/:uuid/query`

TODO

## Streaming API

TODO

### `GET /stream`

TODO

# Appendix

## Example schemas

### Example kanban schema

The following example schema defines all object classes and relations
necessary for a simple Kanban system. It includes:

* users,
* views (different perspectives on a subset of the lanes),
* lanes (ordered lists of cards),
* milestones (deadlines cards can be associated with),
* cards (small tasks assigned to one or more users, organised
  in lanes),
* comments (for cards),
* and tags (for cards and milestones).

This is pretty elaborate already. All it takes to define the above
classes and link them together is this:

    uuid: org.yourproject.kanban.schema.1
    classes:
      user:
        properties:
          name:
            type: text
          email:
            type: text
      view:
        properties:
          title:
            type: text
          description:
            type: text
          lanes:
            type: list
            elements:
              type: reference
              class: lane
              bidirectional: views
      lane:
        properties:
          title:
            type: text
          description:
            type: text
          color:
            type: text
            regex: ^([0-9abcdefABCDEF]{2}){3}$
          views:
            type: list
            elements:
              type: reference
              class: view
              bidirectional: lanes
          cards:
            type: list
            elements:
              type: reference
              class: card
              bidirectional: lanes
      milestone:
        properties:
          title:
            type: text
          description:
            type: text
          color:
            type: text
            regex: ^([0-9abcdefABCDEF]{2}){3}$
          deadline:
            type: text
            regex: ^[0-9]{4}-[0-9]{2}-[0-9]{2}$
          cards:
            type: list
            elements:
              type: reference
              class: card
              bidirectional: lanes
          tags:
            type: list
            elements:
              type: reference
              class: tag
      card:
        properties:
          title:
            type: text
          description:
            type: text
          estimate:
            type: int
          lane:
            type: reference
            class: lane
            bidirectional: cards
          milestone:
            type: reference
            class: milestone
            bidirectional: cards
          assignees:
            type: list
            elements:
              type: reference
              class: user
          comments:
            type: list
            elements:
              type: reference
              class: comment
              bidirectional: card
          tags:
            type: list
            elements:
              type: reference
              class: tag
      comment:
        properties:
          author:
            type: reference
            class: user
          text:
            type: text
          card:
            type: reference
            class: card
            bidirectional: comments
      tag:
        properties:
          title:
            type: text
          description:
            type: text

### Example issues schema

TODO
