% Consonant Specification, Version 0.0
% Daniel Silverstone (<daniel.silverstone@codethink.co.uk>);
  Jannis Pohlmann (<jannis.pohlmann@codethink.co.uk>)
% July 25th, 2013

# Issues to fix

* What if the `consonant.yaml` file changes over time. What if the
  schema being used changes incompatibly or the `consonant.yaml` file
  out of a sudden points to a different version of a schema?
  What if the UUID changes? What if the schema is different between
  different branches of a store?
* Do we know that Git copes well with trees that have thousands of
  entries? Hack up a test repository and run something with pygit2
  against it.
* We need to define that bidirectional references may only define
  pairs, not triangles etc.
* We should probably separate the data model and the data interface
  into separate specifications. The web API might change and advance
  to another version independently of the data model.
* The web API does not have a feature for including hidden objects,
  e.g. via a `?hidden=true` filter.
* The HTTP response code behavior is not documented yet.
* We might want to define a common YAML/JSON body for error responses;
  this is particularly important for transactions of course but also
  for read methods where you might want to know what doesn't exist:
  the class, the object in the class or the property that you've asked
  for.
* Do we want to support pagination when requesting a lot of objects?
* The mandatory `content-type` property for attachment meta data is not
  not documented yet.

# Introduction

## What is Consonant?

*Consonant* is an object-relational, cross-referenced, verifiable and
service-oriented Git object store and corresponding web API. It is named
after the adjective *consonant* ("characterized by harmony or
agreement"), reflecting its focus on a unified data model and
cross-store referencing and validation.

Consonant is the name given to the overall design. Any implementation
that implements this specification, i.e. uses the same data model and
provides the same API, may call itself a "Consonant implementation".

## Motivation

One of the key aspects of our recent work on Baserock and other projects
has been something we call *traceability*—the ability to tell how data
changed over time, who changed what and why, and how the data in
question looked like at a specific point in time.

Examples are:

* The requirements and architecture of projects tend to change over
  time. In this context it is often beneficial to understand who
  approved changes when and how the planned work changed over time.
* Kanban is a popular solution for organising work of teams. When
  assessing project productivity and progress, it is essential to have
  ways of telling how a kanban changed over time, e.g. how many cards
  were moved in a day or a week or how the cards linked to a milestone
  have changed from week to week. Among other things this helps
  understanding how realistic milestones are and whether adjustments
  have to be made.

## Key concepts

In order to support the development of applications that need traceable
data stores, we have identified the need for the following:

* A generic object store in Git:
    - object-relational,
    - database-like,
    - versioned,
    - branchable,
    - versatile.
* Representation of objects as YAML files:
    - unique IDs,
    - properties,
    - readable and editable by humans and machines alike,
    - plain text, useful for diffs.
* References between objects in different data stores:
    - verifiable,
    - versioned.
* Service-oriented design to allow rapid development of interconnected
  web applications on top of Git object stores.

Consonant aims to satisfy these demands by specifying

* a Git/YAML based data model with schemas for type checking and
  validation,
* a standard web API for querying and modifying object stores based on
  this data model,
* a mechanism for referencing objects across different stores.

## Why not use an existing database?

There are a number of reasons for choosing Git over existing relational
or NoSQL databases. Like NoSQL databases, Git is—at its core—a
key-value store for arbitrary data. On top of this, Git offers
versioning, branching and merging, transactions (commits),
de-duplication, offline work and authorship information out of the box,
whereas with other databases you would have to implement a lot of this
yourself.

## Terminology

This specification aims to use consistent terms for the different
aspects of the Consonant design.

* A *Consonant store* is a Git repository whose contents follows the
  Consonant data model.
* A *Consonant service* is a service that provides access to a
  Consonant store via the Consonant web API.
* A *Consonant register* is a YAML file that maps Consonant schema and
  service UUIDs to Consonant services.
* A *Consonant schema* is a YAML file that defines classes for objects
  with typed properties.

# Consonant stores / data model

Representing arbitrary objects in Git requires a unified data model,
allowing different software implementions to access and modify these
objects in a compatible way. This section describes the data model for
Consonant stores.

The central elements of the data model specified in the following
sections are:

* store repositories and service references,
* schemas and schema references,
* classes,
* objects,
* properties,
* attachments.

## Store repository

Every Consonant store is a Git repository. As such it is typically
represented as a directory that holds the Git key/value store and
that can (usually) be accessed remotely via different protocols.
The Git key/value store consists of data that is addressed by a
SHA1 of its content. The following data elements exist in Git and
are relevant to Consonant:

* *blob*: a file with specific content,
* *tree*: a directory of specific subtrees and blobs,
* *commit*: a specific tree, annotated with a list of parent commits
  and other meta data, such as author, committer, commit message and
  so on.

All of the above are stored in Git based on the SHA1 of their contents.
Two files with the same content would result in a single blob that may
be referenced by different trees. Two commits that have the same parents
and introduce the same changes will result in two different commit
elements that reference the same tree (with the modifications made) and
so on.

In addition to the above, heads (flexible, often refered to as branches)
and tags (fixed) can be used to point to specific commits (and therefore
the complete history of a Git tree).

Together this provides the underlying storage mechanism for Consonant
stores.

## Trees and their structure

From here on, *tree* refers to the fully resolved tree of trees
normally associated with a Git commit. Each tree, whether associated
with a commit or not, represents a particular version or revision of
the store's data. The following elements are present in a tree:

1. A top-level `consonant.yaml` file that contains
    - the store UUID,
    - a reference to the schema defining the object classes used in
      the store,
    - a set of aliased references to external services for
      cross-linking.
2. One top-level directory for each object class for which objects
   have been created (e.g. `/card/`, `/lane/`, `/user/`).
3. One directory in the corresponding object class directory for
   each object that has been created (e.g.
   `/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270/`).
4. One `properties.yaml` file in each object directory, storing the
   properties of the object.
5. An optional `attachments/` directory inside each object directory,
   holding arbitrary attachments in pairs of `attachments/<name>` and
   `attachments/.<name>.yaml` files, the latter storing attachment meta
   data.

### Example tree

This is how an example tree for a simple kanban system could look like:

    consonant.yaml
    lane/
        9f03afc6-20c3-4757-a671-2bcdccd47f46/
            properties.yaml                   # title: Backlog
        6453247f-4aed-4233-bf5a-51e056d9f080/
            properties.yaml                   # title: Doing
        8c5bba15-8f70-486a-89fc-fa5a964ee624/
            properties.yaml                   # title: Done
    card/
        0cca0d5f-25a2-4b2f-a8ad-7f647aedb2df/
            properties.yaml                   # number: 129
            attachments/
                foo.txt
                .foo.txt.yaml
                bar.png
                .bar.png.yaml
        .f59d7c0b-ddac-429d-820b-9867794a9a93/
            properties.yaml                   # number: 483

## The `consonant.yaml` file

This file defines the universally unique ID (UUID) and structure of
the store as well as external stores that objects are or may be
linking to.

It is a YAML file with three top-level keys:

1. `uuid`: Defines the unique ID of the store. The format of store
   UUIDs is specified in the *UUIDs* section.
2. `schema`: A schema reference stating the schema being used in the
   store. This schema defines the object classes available in the store
   and specifies names and types of object properties. For the format
   of schema references see *Schema references*.
3. `services`: A dictionary mapping (preferably short) aliases to
   service references, allowing short and readable cross-references to
   objects in external stores. The exact format of service references
   is specified in *Service references*.

### Schema references

Schema references are strings in one of the following formats,
referencing local or remote schemas:

1. `<schema UUID>`: Reference to a schema by UUID. This reference is
   resolved via the Consonant register (see the *Consonant register*
   section).
2. `<scheme>://<url to a schema>`: URL to a schema file. Implementations
   are required to support `http`, `https` and `file` URLs.

### Service references

Service references are strings in one of the following formats,
referencing external Consonant services.

1. `<service UUID>`: Reference to a service by UUID. This reference is
   resolved via the consonant register (see the *Consonant register*
   section).
2. `<scheme>://<url to a service>`: URL to a Consonant service.
   Implementations are required to support `http`, `https` and `file`
   URLs. `file` URLs specify local Consonant stores rather than service
   end points, which implies that implementations resolving `file` URLs
   need to be able to activate services for these stores on demand.

### Example `consonant.yaml` file

The following example shows a hypothetical `consonant.yaml` file for
a kanban system that uses its own schema and supports cross-references
to a bug tracking system built on top of Consonant.

    uuid: org.yourproject.kanban.store
    schema: org.yourproject.kanban.schema.1
    stores:
        issues: http://issues.yourproject.org/

## Object classes

Object classes are defined by the schema used in a Consonant store.
Each class for which objects have been created is represented by
a top-level directory that is named after the name of the class, as
specified in the store's schema.

Examples are `/card/`, `/lane/`, `/milestone/` for card, lane and
milestone objects in a kanban system or `/project/`, `/component/` and
`/issue/` for project, component and issue objects in a bug tracker.

## Objects

Each object created in a Consonant store is represented by an object
directory inside the corresponding class directory. Object directories
are named after object UUIDs. The format of object UUIDs is described
in the *Object UUIDs* section.

Examples of object directories in a Consonant tree are

* `/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270/`,
* `/lane/c675a494-9616-41aa-9833-5629029f6c41/`, or
* `/milestone/a64c6577-e810-4d7b-922c-2a94c3dd644b/`.

Objects would be useless if all they consisted of was a class and a
name. Like in many programming languages, Consonant objects have
so-called properties. They come in three variants:

1. a special property to hide objects,
2. properties specified by schemas and set in `properties.yaml` files,
3. arbitrary data properties called *attachments*.

### Hidden objects

A feature of Consonant stores is that objects can be hidden by
prepending a dot to their directory name (e.g.
`/card/.3652ccf3-0aa3-4974-88a3-37cd8b74a270/`). This is similar to
marking files as hidden in a file system.

Hidden objects are not parsed and loaded into memory unless explicitly
requested. Depending on the amount of data, this can result in
significant performance boosts. However, hidden objects still remain
present in the store so that their existence and history can be
determined without having to locate them in the revision history of
the entire store.

Hiding files can have different semantic meanings. One example would
be "archiving" cards in a kanban system in order to mark them as
obsolete while at the same time preserving a view of all archived
cards for project managers and statistics.

### The `properties.yaml` file

The `properties.yaml` files contain the mandatory and optional
properties for individual objects. There is one file for each object,
located in the object directory (e.g.
`/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270/properties.yaml`).

Like the file extension suggests, `properties.yaml` files are YAML
files. They each hold a flat dictionary that maps property names to
property values. The data types supported for properties are explained
in the *Schemas* section.

#### Example `properties.yaml` file

The following example shows a hypothetical `properties.yaml` file for
a lane in a kanban system, including the properties `name` (text),
`description`, `color` (text), `cards` (list of internal references
to objects of the class `card`).

    title: Doing
    description: |
        Tasks that are currently being worked on. Cards are
        being moved here from the "Backlog" and are moved to
        "Done" after being processed.
    color: #ffa500
    cards:
        - uuid: 3652ccf3-0aa3-4974-88a3-37cd8b74a270
        - uuid: 1b1f1146-72c5-4890-9501-068ddb0560be
        - uuid: 2066c664-a8fe-494f-bddf-756be267fb3c

### The `attachments` directory

In addition to regular properties that are defined in schemas, each
object may store arbitrary properties called *attachments*. These are
stored as pairs of files in an `attachments/` subdirectory inside the
object directory (e.g.
`/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270/attachments/`).

Attachments consist of a name (e.g. `comments` or `mockup.png`),
the actual data and arbitrary YAML meta data. All this is stored in
the `attachments/` directory as follows:

1. `attachments/NAME`: holds the attachment data,
2. `attachments/.NAME.yaml`: holds the attachment meta data,

where `NAME` is the name of the attachment. Attachment names may
not start with a dot and may not contain slashes. Unlike object
properties that are validated via Consonant schemas, there is no
defined validation scheme for attachment meta data. This is entirely
left up to applications built with Consonant.

#### Example `attachments` directory

The following example shows a hypothetical listing of an attachments
directory for issue `6031` in a bug tracker:

    /issue/5d4c394d-cb88-4d98-954f-85f17fe51948/attachments/
        patch-v1.patch
        .patch-v1.patch.yaml
        patch-v2.patch
        .patch-v2.patch.yaml

The YAML meta data in `.patch-v1.patch.yaml` could look like this:

    description: |
        This patch is a first attempt at fixing issue 6031.
        It is caused by accidently overwriting the value of
        `foo` in the for loop in `bla.c`.
    patch: true
    content-type: text/plain

## UUIDs

Universally unique identifiers (UUIDs) are being used to refer to other
objects, schemas or stores/services. Universality of identifiers is not
enforced: while creators of schemas and stores are encouraged to use
globally unique identifiers (see below), there is no way to guarantee
this. Identifiers of objects only have to be unique within a store.

### Object UUIDs

Identifiers of objects are required to be unique within a store. Their
generation is left to Consonant implementations. However, they must be
a mix of alphanumeric characters and dashes and must not begin or end
with a dash:

    ^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])$

The use of standard UUIDs (see
<http://en.wikipedia.org/wiki/Universally_unique_identifier>) is
strongly recommended.

It is mandatory that applications place no semantic meaning on object
UUIDs.

### Schema UUIDs

Identifiers of schemas are required to be of the form

    some.domain.schemaname.1

meaning that they follow a reverse domain notation similar to that used
for Java packages/classes and D-Bus service names. A special requirement
is the mandatory final segment of the UUID, which specifies the schema
version:

    ^[a-zA-Z][a-zA-Z0-9-]*(\.[a-zA-Z][a-zA-Z0-9-]*)*\.[0-9]+$

### Store/service UUIDs

Identifiers of stores/services are required to be of the form

    some.domain.storename

meaning that they follow the same reverse domain notation as schema
UUIDs except for not requiring a version number segment at the end:

    ^[a-zA-Z][a-zA-Z0-9-]*(\.[a-zA-Z][a-zA-Z0-9-]*)$

## The Consonant register

The *Consonant register* is a special configuration file that allows
to register Consonant services and schemas system-wide or per-user. It is
is used to resolve UUID-based schema and store imports in
`consonant.yaml`.

The Consonant register is located according to the
[XDG Base Directory Specification](http://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html),
that is, the system register is stored in

    $XDG_CONFIG_DIRS/consonant/register.yaml

and the user register is stored in

    $XDG_CONFIG_HOME/consonant/register.yaml

Register files are YAML files that contain the following two keys:

1. `schemas`: a dictionary mapping schema UUIDs and URLs to local file
   paths.
2. `services`: a dictionary mapping service UUIDs to service URLs.

Whenever the same UUID appears in both the system-wide register
and the per-user register the mapping in the user register takes
precedence and overrides the system-wide one.

### Example register

The following examples shows a hypothetical system and user register
defining mappings for schemas and stores for a kanban and bug tracking
system. The user mapping for the bug tracker overrides the system-wide
setting for a local installation of the bug tracking service (and
store).

System register:

    schemas:
        org.project.kanban.schema.1: >
            /usr/share/consonant/schemas/org.project.kanban.schema.1
        org.project.issues.schema.1: >
            /usr/share/consonant/schemas/org.project.issues.schema.1

Registry of user `jeff`:

    stores:
        org.project.issues.store: http://localhost:8080/

## Schemas

Schemas are YAML files that define the object classes available for
use in a Consonant store.

### Schema files

Schemas are defined via YAML files, of which there is one per schema.
Schema files contain the following top-level keys:

* `uuid`: the UUID of the schema (see the *Schemas* section for more
  information).
* `classes`: a mapping of class names to class definitions, each
  consisting of a set of property definitions.

### Class definitions

Classes are defined via a class name that is mapped to a set of object
property definitions inside the `classes` key in schema files.

The class name is the key the class is stored under in `classes`. Class
names are limited to alphanumeric characters mixed with dashes. They
must begin with a letter, may not end with a dash and must have a
minimum length of 2 characters:

    ^[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9]$

The `properties` key under the class definition maps object property
names to their definitions.

The following example shows (partial) hypothetical schema for a kanban
system based on Consonant, defining two classes for kanban lanes and
cards, respectively:

    uuid: org.yourproject.kanban.schema1
    classes:
        lane:
            properties:
                ...
        cards:
            properties:
                ...

### Object properties

Object properties are defined as a dictionary under the `properties`
key of class definitions. Each property definition includes

* a name,
* a data type,
* an `optional` flag, and
* data type specific hints (e.g. validation rules).

### Property names

Property names are alphanumeric strings that may contain dashes as
delimiters. Property names must start with a letter and may not end with
a dash. They must have a minimum length of 2 characters. Property
names can be validated using the following regular expression:

    ^[a-zA-Z][a-zA-Z0-9-]*[a-zA-Z0-9]$

Examples of valid property names are: `id`, `title`, `email-address`,
`property1`.

### Property data types

Object properties are strictly typed, meaning that each property is
associated with a data type and optional validation rules. This
information is used by Consonant implementations to validate entire
data stores.

The following table lists all data types supported by Consonant schemas.

+-------------+-------------------------------------------------------------+
| Name        | Description                                                 |
+=============+=============================================================+
| boolean     | Data type with only two possible values: `true` or `false`. |
+-------------+-------------------------------------------------------------+
| int         | Data type for 64 bit signed integers.                       |
+-------------+-------------------------------------------------------------+
| float       | Data type for double-precision floating-point numbers.      |
+-------------+-------------------------------------------------------------+
| text        | Data type for arbitrary text. Whitespace is preserved.      |
+-------------+-------------------------------------------------------------+
| reference   | Data type for references to other objects, either in the    |
|             | same or a different Consonant store.                        |
+-------------+-------------------------------------------------------------+
| list        | Data type for lists of values of another basic data type.   |
|             | Lists may be nested.                                        |
+-------------+-------------------------------------------------------------+

### Properties of type `boolean`

#### Definition

Boolean properties are specified in schema files as follows:

    <name>:
        type: boolean

#### Usage

Assume we were to write a Consonant schema for a kanban system. Kanban
cards might have a boolean property `doable` to mark them as small
tasks that can be completed in less then a day. In the schema, this
would look as follows:

    uuid: org.yourproject.kanban.schema.1
    classes:
        card:
            properties:
                doable:
                    type: boolean

A card `/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270` might have this
property set, in which case its `properties.yaml` file in the
corresponding Consonant store would look like this:

    doable: true

#### Values

Allowed values of boolean properties are: `true`, `false`.

### Properties of type `int`

#### Definition

Integer properties are specified in schema files as follows:

    <name>:
        type: int

#### Usage

Assume we were to write a Consonant schema for a kanban system. Kanban
cards might have an optional `estimated-days` property to estimate the
amount of days needed to finish the corresponding tasks. The resulting
schema would look as follows:

    uuid: org.myproject.kanban.schema.1
    classes:
        card:
            properties:
                doable:
                    type: boolean
                estimated-days:
                    type: int
                    optional: true

Any card (e.g. `/card/3652ccf3-0aa3-4974-88a3-37cd8b74a270`) might have
this property set, resulting in `properties.yaml` files like the
following:

    estimated-days: 3
    doable: false

The above includes the `doable` property from the boolean property
example to demonstrate how a `properties.yaml` file with multiple
properties would look like.

#### Values

All `int` properties are 64 bit integers with allowed values ranging
from -9,223,372,036,854,775,808 to +9,223,372,036,854,775,807.

### Properties of type `float`

#### Definition

Floating point properties are specified in schema files as follows:

    <name>:
        type: float

#### Usage

Assume we were to write a Consonant schema for a personal finance
system with multiple bank accounts. A bank account might have a
floating point property for the current amount of money in the
account. The resulting schema would
look as follows:

    uuid: uk.me.yourname.banking.schema.1
    classes:
        account:
            properties:
                name:
                    type: string
                current-amount:
                    type: float

Every account (e.g. `/account/29f585ca-b246-4eea-9d79-a34904f8f19a`)
would have to have this property set, resulting in `properties.yaml`
files like the following:

    name: Personal Savings
    current-amount: 159.27

#### Values

All floating point properties support double precision values.

### Properties of type `text`

#### Definition

Text properties are defined in schemas as follows:

    <name>:
        type: text

They may optionally include a regular expression as a validation
requirement for implementations:

    <name>:
        type: text
        regex: <regular expression>

#### Usage

Assume we were to define a Consonant schema for a kanban system that
includes lanes with a title, an optional description and a CSS color.
The schema for this might look as follows:

    uuid: org.yourproject.kanban.schema.1
    classes:
        lane:
            properties:
                title:
                    type: text
                description:
                    type: text
                color:
                    type: text
                    regex: ^#([0-9abcdefABCDEF]{2}){3}$

Lanes in the store would now have `properties.yaml` files like the
following:

    title: Doing
    description: |
        Tasks that are currently being worked on
        by a member of the project.
    color: #a7d239

#### Values

Text properties can store arbitrary text including whitespace that is
preserved by the store. If a `regex` validation rule is defined, the
value of the text property must in addition satisfy the given regular
expression.

### Properties of type `list`

#### Definition

List properties are defined in schemas as follows:

    <name>:
        type: list
        elements:
            <type definition for elements>

One example would be a list of lists of strings:

    <name>:
        type: list
        elements:
            type: list
            elements:
                type: string

Lists are required to always contain at least one element. The
`optional` flag can be used to define list properties that may be empty
(by not being set at at all).

#### Usage

Assume we were to define a Consonant schema for a kanban system with
cards that optionally have arbitrary strings attached as tags. The
resulting schema might then look like this:

    uuid: org.yourproject.kanban.schema.1
    classes:
        card:
            properties:
                title: string
                tags:
                    type: list
                    elements:
                        type: string
                    optional: true

A card could now have the following `properties.yaml` file including
a list of tags:

    title: Fix bug #5302
    tags:
        - bug
        - priority1

#### Values

If present in `properties.yaml` files, lists must be non-empty. Empty
list properties are realised through the `optional` flag. The allowed
values of list elements depend entirely on the element data type
specified.

### Properties of type `reference`

#### Definition

Reference properties are used to describe references from one object
to another. References may be internal (within the same store) or
external (to objects in a different store). References may also include
a particular target tree or commit (again, in the same or a different
store). Another feature of object references in Consonant is that they
can be unidirectional or bidirectional.

Internal reference properties are defined as follows:

    <name>:
        type: reference
        class: <target class name>

Reference properties for linking to objects in another store are
defined by adding a schema UUID to the property definition:

    <name>:
        type: reference
        class: <target class name>
        schema: <schema UUID>

Note that the above only specifies the schema, allowing Consonant
implementations to locate the class definition of referenced objects
from the schema the UUID is resolved to. The schema does not specify
in which store(s) the referenced external objects are held. This
is purely encoded in the actual property values and may vary from
store to store.

The above definitions define one-way/unidirectional object references.
The `bidirectional` hint may be used to define bidirectional
references. The value of `bidirectional` is the name of a property
of the referenced objects that is expected to hold a reference in
the other direction. Note that the property named by the `bidirectional`
hint may be a list, allowing not just one-to-one bidirectional
references but also one-to-many or many-to-many relationships to be
defined:

    <name>:
        type: reference
        class: <target class name>
        bidirectional: <property name of the target class>

Note: Bidirectional reference properties are only supported for
*internal* references, not for references to objects in another store.

#### Usage

Assume that we were to define a schema for a kanban system with lanes
and cards, where lanes and cards have a one-to-many relationship and
cards may optionally refer to external issue objects in an issue
tracker. The kanban schema for this could include the following:

    uuid: org.yourproject.kanban.schema.1
    classes:
        lane:
            properties:
                title: text
                cards:
                    type: list
                    elements:
                        type: reference
                        class: card
                        bidirectional: lane
        card:
            properties:
                title: text
                lane:
                    type: reference
                    class: lane
                    bidirectional: cards
                issue:
                    type: reference
                    class: issue
                    schema: org.yourproject.issues.schema.1
                    optional: true

With this, every lane in the kanban store would have to have a list of
the cards in the lane in the `cards` property. An example could be the
`properties.yaml` file of a lane with the UUID `doing`:

    title: Doing
    cards:
        - uuid: 2a4f3b0a-b828-40f7-aa4b-ce57480ede52
        - uuid: 998229a6-0562-43c8-8122-7c813603ed9f
        - uuid: 6cc4efed-3a0e-47c5-b387-17e2b3c48d6d

Cards on the other hand would have to have a reference back to the
lane they are in via the `lane` property` and could additional store
a reference to an external issue:

    title: Fix bug #5942
    lane: doing
    issue:
        service: issues
        uuid: ab63d142-0af1-45a8-b813-8dd7e39ffd6e

where `issues` is a alias for the issue tracker service defined in
`consonant.yaml` and `ab63d142-0af1-45a8-b813-8dd7e39ffd6e` is the
UUID of an issue in this issue tracker.

#### Values

The format and allowed content of references depends on whether they
are internal or external. Internal references are specified as a
a dictionary:

- `uuid`: the target object's UUID,
- `ref`: an optional Git ref, tree, commit or tag of the Consonant
  store.

Similarly, external references are specified via a dictionary with
the following keys:

* `uuid`: the UUID of the referenced object,
* `service`: a service alias resolved via the `consonant.yaml` file of
  the store,
* `ref`: an optional Git ref, tree, commit or tag of the target
  Consonant store.

# Consonant services / data interface

Through the data model described in the previous chapter, Consonant
stores already provide an interface to the data that applications can
use to access, query and modify objects. To support the rapid
development of web services on top of Consonant stores, however, a
standard web API is desirable.

This chapter defines a standard web API for accessing Consonant stores.
Implementations of this web API are called *Consonant services*.

## Web API characteristics

This section covers some of the main characteristics of the web API,
along with explanations of why they are so important.

### API versioning

Interfaces almost inevitably change over time. The
changes made may or may not compatible. This is why it is important
to establish a understanding of the interface version being used in
the communication between server and client. Versioning interfaces
has proven to be good practice for protocols (e.g. HTTP 1.0 vs. 1.1),
D-Bus service interfaces (e.g.  `org.freedesktop.systemd1.Manager`)
and web APIs (e.g. `http://api.twitter.com/1/` vs.
`http://api.twitter.com/1.1/`).

The Consonant web API is versioned by being encapsulated in the
following URL prefix:

    http://url.of.service/consonant/api/<version>/

The first version of the API resides under

    http://url.of.service/consonant/api/1.0/

### RESTful design

REST has become a standard approach to designing web APIs. Consonant
follows the same principles, including

* a client-server model,
* stateless communication (services store no client state),
* cacheable responses,
* support for transparent addition of layers on top of the underlying
  store without affecting the web API,
* a uniform interface to the data that all Consonant services
  implement.

Note that the above does not apply to the streaming API defined in
the *Streaming API* section, which involves client state being stored
on the server side as well as making it impossible to cache most of the
communication.

### Support for both YAML and JSON

Since the underlying data model uses YAML to represent schemas, store
configurations as well as objects and their properties it seems natural
to formulate the web API in terms of exchanging YAML data. However,
many clients will find it easier to generate and process JSON,
especially those written in JavaScript.

To compensate for this problem, all methods of the Consonant web API
accept or return both YAML and JSON.

Request data has to be marked appropriately by setting either
`Content-Type: application/x-yaml` or
`Content-Type: application/json` in the HTTP request header.

The desired response format has to be specified by setting the `Accept`
header to either `Accept: application/x-yaml` or
`Accept: application/json` when sending an HTTP request that will
result in a response with data.

#### YAML versus JSON example

The following example shows the same `GET` request being made with
`Accept: application/x-yaml` and `Accept: application/json`. In the
rest of this chapter, all examples will use YAML but you can safely
assume that JSON can be used in exactly the same way.

First, the request using YAML:

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/schema                               |
|                      |     Accept: application/x-yaml                                  |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     Content-Type: application/x-yaml                            |
|                      |                                                                 |
|                      |     uuid: org.yourproject.kanban.schema.1                       |
|                      |     classes:                                                    |
|                      |       lane:                                                     |
|                      |         properties:                                             |
|                      |           title:                                                |
|                      |             type: text                                          |
|                      |           cards:                                                |
|                      |             type: list                                          |
|                      |             elements:                                           |
|                      |               type: reference                                   |
|                      |               class: card                                       |
|                      |               bidirectional: lane                               |
|                      |       card:                                                     |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

Second, the same request using JSON:

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/schema                               |
|                      |     Accept: application/json                                    |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     Content-Type: application/json                              |
|                      |                                                                 |
|                      |     {                                                           |
|                      |       "uuid": "org.yourproject.kanban.schema.1",                |
|                      |       "classes": {                                              |
|                      |         "lane": {                                               |
|                      |           "properties": {                                       |
|                      |             "title": {                                          |
|                      |               "type": "text"                                    |
|                      |             },                                                  |
|                      |             "cards": {                                          |
|                      |               "type": "list"                                    |
|                      |               "elements": {                                     |
|                      |                 "type": "reference"                             |
|                      |                 "class": "card"                                 |
|                      |                 "bidirectional": "lane"                         |
|                      |               }                                                 |
|                      |             }                                                   |
|                      |           }                                                     |
|                      |         },                                                      |
|                      |         "card": {                                               |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

## Basic API

The basic Consonant web API includes a set of `GET` methods to retrieve
the schema used by the underlying store, classes, objects, properties,
attachments and Git refs such as branches and tags. It also includes a
`POST` method to modify objects in the store in the form of
transactions.

### `GET /schema`

Returns the schema used by the underlying store managed by the Consonant
service. Use the HTTP `Accept` header to specify whether the schema
should be returned as YAML or JSON:

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/schema                               |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     uuid: org.yourproject.kanban.schema.1                       |
|                      |     classes:                                                    |
|                      |       lane:                                                     |
|                      |         properties:                                             |
|                      |           title:                                                |
|                      |             type: text                                          |
|                      |           cards:                                                |
|                      |             type: list                                          |
|                      |             elements:                                           |
|                      |               type: reference                                   |
|                      |               class: card                                       |
|                      |               bidirectional: lane                               |
|                      |       card:                                                     |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

### `GET /classes`

Returns a YAML or JSON dictionary mapping the names of all classes
available in the store to some meta data, including:

* the number of objects of the class,
* ...?

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes                              |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     lane:                                                       |
|                      |       objects:                                                  |
|                      |         total:  7                                               |
|                      |         active: 5                                               |
|                      |         hidden: 2                                               |
|                      |     card:                                                       |
|                      |       objects:                                                  |
|                      |         total:  233                                             |
|                      |         active: 217                                             |
|                      |         hidden: 16                                              |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class`

Like `GET /classes` but fetches the meta data for a single class only.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/lane                         |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     lane:                                                       |
|                      |       objects:                                                  |
|                      |         total:  7                                               |
|                      |         active: 5                                               |
|                      |         hidden: 2                                               |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects`

Fetches all objects of a given class, including their properties and
attachment names. The response does not include any attachment meta
data or content. Object references are not resolved recursively; this
is the responsibility of the client.

The objects of the class are returned as a list of dictionaries.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/card/objects                 |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     - uuid: ccb920a2-810a-4264-b022-d92f36f849bf                |
|                      |       class: card                                               |
|                      |       hidden: false                                             |
|                      |       properties:                                               |
|                      |         title: Fix bug #5932                                    |
|                      |         comments:                                               |
|                      |           - uuid: e96dcdf9-fd5f-4e66-af73-58db9ee15701          |
|                      |           - uuid: b7dbfd80-8afd-44a7-a636-f69c5a9fe517          |
|                      |       attachments:                                              |
|                      |         - screenshot.png                                        |
|                      |     - uuid: 445bf6d4-6dd2-4817-a657-27329b5fbff8                |
|                      |       class: card                                               |
|                      |       hidden: false                                             |
|                      |       properties:                                               |
|                      |         title: Implement feature XYZ                            |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid`

Takes a class name and object UUID and returns the properties and
attachment names for the corresponding object. Returns a 404 if the
class does not exist or if the object UUID does not refer to an object
of the given class.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/lane/objects/...             |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca                  |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     class: lane                                                 |
|                      |     hidden: false                                               |
|                      |     properties:                                                 |
|                      |       title: Backlog                                            |
|                      |       cards:                                                    |
|                      |         - uuid: c545a172-6960-411c-bd06-e4cd9efb2a29            |
|                      |         - uuid: f985009e-e52b-4f4c-a6bd-34d27462e000            |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/properties`

Takes a class name and object UUID and returns the properties for the
corresponding object. Returns a 404 if the class does not exist or if
the object UUID does not refer to an object of the given class.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/lane/objects/...             |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca/...              |
|                      |           properties                                            |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     title: Backlog                                              |
|                      |     cards:                                                      |
|                      |       - uuid: c545a172-6960-411c-bd06-e4cd9efb2a29              |
|                      |       - uuid: f985009e-e52b-4f4c-a6bd-34d27462e000              |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/properties/:property`

Takes a class name, an object UUID and a property name and returns the
value of the corresponding object property. Returns a 404 if the class
does not exist, if the object UUID does not refer to an object of the
given class or if a property with the given name does not exist in the
class.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/lane/objects/...             |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca/...              |
|                      |           properties/title                                      |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     Backlog                                                     |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/attachments`

Takes a class name and an object UUID and returns a dictionary mapping
the names of all attachments of the corresponding objec to their meta
data.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/card/objects/...             |
|                      |           ccb920a2-810a-4264-b022-d92f36f849bf/...              |
|                      |           attachments                                           |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     screenshot.png:                                             |
|                      |       content-type: image/png                                   |
|                      |       properties:                                               |
|                      |         description: Screenshot of the bug.                     |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/attachments/:name`

Takes a class name, an object UUID and an attachment name and returns
the meta data for the attachment. Returns a 404 if the class does not
exist, if the object UUID does not refer to an object of the given
class or if no attachment with the given name exists for the object.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/classes/card/objects/...             |
|                      |           ccb920a2-810a-4264-b022-d92f36f849bf/...              |
|                      |           attachments/screenshot.png                            |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     content-type: image/png                                     |
|                      |     properties:                                                 |
|                      |       description: Screenshot of the bug.                       |
+----------------------+-----------------------------------------------------------------+

### `GET /classes/:class/objects/:uuid/attachments/:name/data`

Takes a class name, an object UUID and an attachment name and returns
the data of the attachment. The response has the `Content-Type` header
set to the `content-type` of the attachment meta data. Returns a 404
if the class does not exist, if the object UUID does not refer to an
object of the given class or if no attachment with the given name
exists for the object.

### `GET /objects`

Returns all objects defined in the store, including their properties and
attachment names. The response does not include any attachment meta data
or content. Object references are not resolved recursively; this is the
responsibility of the client.

The result is a dictionary that maps class names to lists of objects.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/objects                              |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     lane:                                                       |
|                      |       - uuid: b5decbb8-54b6-49a7-923b-7c3e04dfadca              |
|                      |         class: lane                                             |
|                      |         hidden: false                                           |
|                      |         properties:                                             |
|                      |           title: Backlog                                        |
|                      |           cards:                                                |
|                      |             - uuid: c545a172-6960-411c-bd06-e4cd9efb2a29        |
|                      |             - uuid: f985009e-e52b-4f4c-a6bd-34d27462e000        |
|                      |         attachments:                                            |
|                      |           - screenshot.png                                      |
|                      |       - uuid: dcb7a3e2-0da2-4ca9-befe-122ddd2b9ac2              |
|                      |         class: lane                                             |
|                      |         ...                                                     |
|                      |     cards:                                                      |
|                      |       - uuid: d75be68f-412f-4a5a-b59b-2c4e9cb94b2c              |
|                      |         class: card                                             |
|                      |         ...                                                     |
+----------------------+-----------------------------------------------------------------+

### `GET /objects/:uuid`

Takes an object UUID and returns the properties and attachment names
for the corresponding object. Returns a 404 if the object UUID does not
refer to an existing object in the store.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/objects/...                          |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca                  |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     class: lane                                                 |
|                      |     hidden: false                                               |
|                      |     properties:                                                 |
|                      |       title: Backlog                                            |
|                      |       cards:                                                    |
|                      |         - uuid: c545a172-6960-411c-bd06-e4cd9efb2a29            |
|                      |         - uuid: f985009e-e52b-4f4c-a6bd-34d27462e000            |
|                      |     attachments:                                                |
|                      |       - screenshot.png                                          |
+----------------------+-----------------------------------------------------------------+

### `GET /objects/:uuid/class`

Takes an object UUID and returns the name of the object class. Returns
a 404 if the object UUID does not refer to an existing object in the
store.

+----------------------+-----------------------------------------------------------------+
| **Example Request**  |     GET /consonant/api/1.0/objects/...                          |
|                      |           b5decbb8-54b6-49a7-923b-7c3e04dfadca/class            |
+----------------------+-----------------------------------------------------------------+
| **Example Response** |     lane                                                        |
+----------------------+-----------------------------------------------------------------+

### `GET /objects/:uuid/properties`

Like `GET /classes/:class/objects/:uuid/properties` except that it
requires no class name and only takes an object UUID.

### `GET /objects/:uuid/properties/:property`

Like `GET /classes/:class/objects/:uuid/properties/:property` except
that it requires no class name and only takes an object UUID and
property name.

### `GET /objects/:uuid/attachments`

Like `GET /classes/:class/objects/:uuid/attachments` except that it
requires no class name and only takes an object UUID.

### `GET /objects/:uuid/attachments/:name`

Like `GET /classes/:class/objects/:uuid/attachments/:name` except that
it requires no class name and only takes an object UUID and attachment
name.

### `GET /objects/:uuid/attachments/:name/data`

Like `GET /classes/:class/objects/:uuid/attachments/:name` except that
it requires no class name and only takes an object UUID and attachment
name.

### `GET /refs`

TODO

### `GET /refs/:ref`

TODO

### `GET /refs/:ref/classes`

TODO

### `GET /refs/:ref/classes/:ref`

TODO

### `GET /refs/:ref/...`

TODO

### `POST /transaction`

TODO

## Query API

TODO

### `POST /query`

TODO

## Streaming API

TODO

### `GET /stream`

TODO

# Appendix

## Example schemas

### Example kanban schema

The following example schema defines all object classes and relations
necessary for a simple Kanban system. It includes:

* users,
* views (different perspectives on a subset of the lanes),
* lanes (ordered lists of cards),
* milestones (deadlines cards can be associated with),
* cards (small tasks assigned to one or more users, organised
  in lanes),
* comments (for cards),
* and tags (for cards and milestones).

This is pretty elaborate already. All it takes to define the above
classes and link them together is this:

    uuid: org.yourproject.kanban.schema.1
    classes:
      user:
        properties:
          name:
            type: text
          email:
            type: text
      view:
        properties:
          title:
            type: text
          description:
            type: text
          lanes:
            type: list
            elements:
              type: reference
              class: lane
              bidirectional: views
      lane:
        properties:
          title:
            type: text
          description:
            type: text
          color:
            type: text
            regex: ^([0-9abcdefABCDEF]{2}){3}$
          views:
            type: list
            elements:
              type: reference
              class: view
              bidirectional: lanes
          cards:
            type: list
            elements:
              type: reference
              class: card
              bidirectional: lanes
      milestone:
        properties:
          title:
            type: text
          description:
            type: text
          color:
            type: text
            regex: ^([0-9abcdefABCDEF]{2}){3}$
          deadline:
            type: text
            regex: ^[0-9]{4}-[0-9]{2}-[0-9]{2}$
          cards:
            type: list
            elements:
              type: reference
              class: card
              bidirectional: lanes
          tags:
            type: list
            elements:
              type: reference
              class: tag
      card:
        properties:
          title:
            type: text
          description:
            type: text
          estimate:
            type: int
          lane:
            type: reference
            class: lane
            bidirectional: cards
          milestone:
            type: reference
            class: milestone
            bidirectional: cards
          assignees:
            type: list
            elements:
              type: reference
              class: user
          comments:
            type: list
            elements:
              type: reference
              class: comment
              bidirectional: card
          tags:
            type: list
            elements:
              type: reference
              class: tag
      comment:
        properties:
          author:
            type: reference
            class: user
          text:
            type: text
          card:
            type: reference
            class: card
            bidirectional: comments
      tag:
        properties:
          title:
            type: text
          description:
            type: text

### Example issues schema

TODO
