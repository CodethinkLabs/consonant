% Generic Git Object Store Specification, Version 0.0
% Daniel Silverstone <daniel.silverstone@codethink.co.uk>;
  Jannis Pohlmann <jannis.pohlmann@codethink.co.uk>
% July 17th, 2013

# Definition

The generic Git object store is an object-relational, cross-referenced,
verifiable and service-oriented data store for arbitrary objects.

# Motivation

One of the key aspects of our recent work on Baserock and other projects
has been what we call traceability—the ability to tell how data changed
over time, who changed what and why, and how the data in question looked
like at a specific point in time.

Two examples are:

* The requirements and architecture of projects changes over time. In
  this context it is often beneficial to know who approved changes when
  and how the overall plan changed over time.
* Kanban is a popular solution for work organisation in teams. When
  assessing and reporting project progress, it is essential to have an
  easy way to tell how a Kanban changed over time, e.g. how many cards
  were moved in a particular period of time.

## Key concepts

In order to support the development of applications that need traceable
data storage, we have identified the need for the following:

* A generic object store in Git
    - object-relational
    - database-like
    - versioned
    - branchable
    - versatile
* Representation of objects as YAML files
    - unique IDs
    - properties
    - readable and editable by humans and machines alike
    - plain text, useful for diffs
* References between objects in different data stores
    - verifiable
    - versioned
* Service-oriented design to allow rapid development of web applications
  on top of Git object stores

The generic Git object store aims to satisfy this demand by specifying

* a Git/YAML based data model with schemas for type checking and
  validation,
* a RESTful web service API for querying and modifying git object
  stores,
* a mechanism to for referencing objects across git object stores,
* a Python base library for rapid development of web services on top
  of Git object stores.

## Why not use an existing database?

There are a number of reason to choose Git over existing relational or
NoSQL databases. Like NoSQL databases, Git is—at it’s core—a key-value
store for arbitrary data. On top of this, Git offers versioning,
branching and merging, transactions (commits), de-duplication, offline
work and authorship information out of the box, whereas with other
databases you would have to implement a lot of this yourself.

# Git/YAML Data Model

Representing arbitrary objects in Git requires a data model that allows
software to be written to access and modify these objects in a unified
way. This section describes the data model chosen for the generic Git
object store.

## Git Repository

Every object store is a Git repository. As such it is represented as a
directory that holds the Git key/value store and that can (usually) be
accessed remotely via different protocols. The Git key/value store
consists of data that is addressed by a SHA1 of its content. The
following data elements exist in Git:

* blob: a file with specific content
* tree: a directory of specific trees and blobs
* commit: a specific tree plus a list of parent commits and other meta
  data like author, committer, commit message etc.

All of the above are stored in Git based on the SHA1 of their contents.
Two files with the same content would result in a single blob that may
be referenced by different trees. Two commits that have the same parents
and introduce the same changes will result in two different commit
elements that reference the same tree (with the modifications made) and
so on.

In addition to the above, heads (flexible, often refered to as branches)
and tags (fixed) can be used to point to specific commits (and therefore
the complete history of a Git tree).

Together this provides the underlying storage mechanism for generic Git
object stores.

## Directory Structure

In the underlying storage mechanism, each Git commit and tree represents
a version or variant of a generic Git object store. The following
directory structure is used to import schema and define objects:

    meta.yaml                       - meta information such as store UUID and schemas used
    class-1/                        - e.g. requirement, component, lane, card, issue, ...
        uuid-1/                     - app-specific object UUIDs, e.g. K1234 for Kanban cards
            properties.yaml         - object properties (e.g. title, description)
                attachments/        - directory for object properties holding arbitrary data (files)
                    foo.txt         - a text file attachment
                    .foo.txt.yaml   - meta data for the text file
                    bar.png         - a PNG image attachment
                    .bar.png.yaml       - meta data for the PNG image
        .uuid-2/                    - a hidden object (marked by the leading “.” in the UUID)
            properties.yaml         - object properties
            ...
    class-2/
        uuid-3/
            properties.yaml
        ...
    ...

## Store, Schema and Object UUIDs

UUIDs for stores and schemas are required to be globally unique and
follow the following format:

([a-zA-Z_]{1}[a-zA-Z0-9_]*(\.[a-zA-Z_]{1}[a-zA-Z0-9_]*)*)?

This is similar to how D-Bus names and JAVA packages/classes are
specified. A few examples of store and schema UUIDs are:

	org.myproject.stores.kanban
	org.myproject.stores.requirements
	org.myproject.schemas.kanban
	org.myproject.schemas.requirements

A versioning scheme is recommended if there are different, incompatible
versions of stores and schemas, e.g.

	org.myproject.schemas.kanban
	org.myproject.schemas.kanban1
	org.myproject.schemas.kanban2

but this is not mandatory.

UUIDs for objects are required to be unique within a store and follow
the following format:

	(^[:\/])+

Example object UUIDs are:

	Kanban cards: K10, K512, K1253
	Issues: 5940, 234
	Customers: uk.co.codethink, org.company.division

## Metadata (meta.yaml)

The meta.yaml file in the root of the tree specifies the following:

The globally unique UUID of the object store
A set of cross-referenced stores, each with an alias and either its globally unique UUID, a local path or a URL to an HTTP object store service.
A set of schemas describing object classes used by the object store, each represented by a globally unique UUID, a local filename or a URL to an HTTP object store service.

An example meta.yaml file of a Kanban store could look as follows:

    uuid: org.myproject.stores.kanban
    stores:
        requirements: http://requirements.myproject.org/
                customers: org.myproject.stores.customers
                issues: http://issues.myproject.org/
    schemas:
        - http://kanban.myproject.org/

## Schemas

Schemas are files that describe the object classes available for use in
an object store. Definitions of classes include a class name and a list
of properties. Each property definition includes a name, basic data type
and data type specific information (e.g. for validating strings).
Properties may also be marked optional via the `optional=<true|false>`
field.

The following basic data types are supported:

--------------------------------------------------------------------------------------
Name    Description                           Extra fields
------- ------------------------------------- ----------------------------------------
string  A single line of text.

regex   A regular expression for validating
        the value of a string property

text    Multiple lines of text.

list    List of values of another data type.  type - basic data type of list elements

ref     Reference to another object.          class - name of the class of referenced
                                              objects
                                              store - alias, UUID, path or URL to an
                                              HTTP object store service that the
                                              holds the referenced objects
-------------------------------------------------------------------------------------

Table: Data types supported by the generic Git object store.

An example schema could look as follows

    org.myproject.schemas.kanban.yaml:
    uuid: org.myproject.schemas.kanban
        lane:
            title:
                kind: string
                regex: ^.*$
            cards:
                kind: list
                type: ref
                class: card
            colour:
                kind: string
                regex: ^#([0-9abcdefABCDEF]{6})$
        card:
            issue:
                kind: ref
                class: issue
                store: issues
                optional: true

